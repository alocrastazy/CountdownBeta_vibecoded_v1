<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Countdown Timer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&family=Poppins:wght@100;200;300;400;500;600;700;800;900&family=Montserrat:wght@100;200;300;400;500;600;700;800;900&family=Space+Grotesk:wght@300;400;500;600;700&family=JetBrains+Mono:wght@100;200;300;400;500;600;700;800&family=Playfair+Display:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">

  <style>
    :root{
      --font-main: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif;
      --focusBlur: 0px;
      --focusSat: 1;
      --focusBri: 1;
--contrast: 100;
      --blur: 0;
      --bloom: 0;
      --bloomOpacity: 1;
            --bloomOpacityEff: 0;
      --bg-img: none;
      --bg-default:
        radial-gradient(900px 600px at 18% 18%, rgba(120, 190, 255, 0.16), transparent 62%),
        radial-gradient(800px 560px at 82% 22%, rgba(200, 130, 255, 0.14), transparent 58%),
        radial-gradient(700px 520px at 50% 86%, rgba(90, 255, 200, 0.10), transparent 56%),
        linear-gradient(180deg, #070710 0%, #04040a 55%, #020208 100%);
--ease-smooth: cubic-bezier(0.2, 0.8, 0.2, 1);
      --theme-text: #ffffff;
      --theme-accent: #9ad1ff;
      --theme-panel: rgba(0, 0, 0, 0.82);
      --theme-border: rgba(255,255,255,0.22);
      --theme-soft: rgba(255,255,255,0.08);
      --theme-accent-soft: rgba(154,209,255,0.24);
    }

    * { box-sizing: border-box; }

    body {
      font-family: var(--font-main);
      font-variant-numeric: tabular-nums;
      font-feature-settings: 'tnum' 1;
      /* v6: configurable background (Default / File / Unsplash). */
      background-color: #05050a;
      background-image: var(--bg-img), var(--bg-default);
      background-size: cover;
      background-position: center;
      background-attachment: fixed;
      color: var(--theme-text); /* Light text for contrast */
      text-align: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      overflow: hidden;
    }

    /* v6: default theme background animation (only when no custom image) */
    body.default-bg{
      background-size: 140% 140%;
      animation: defaultBgMove 18s ease-in-out infinite alternate;
    }
    @keyframes defaultBgMove{
      from{ background-position: 30% 25%; }
      to{ background-position: 70% 75%; }
    }
    @media (prefers-reduced-motion: reduce){
      body.default-bg{ animation: none; }
    }


    .overlay {
      background-color: rgba(0, 0, 0, 0.5); /* Dark overlay for readability */
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: -1;
      backdrop-filter: blur(calc(var(--blur) * 1px));
      filter: contrast(calc(var(--contrast) * 1%));
      transition: filter 450ms var(--ease-smooth), backdrop-filter 450ms var(--ease-smooth);
      will-change: filter, backdrop-filter;
    }


    .bloom-clipper{
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 18px 26px;
      overflow: hidden; /* creates the "bloom border" cut-off */
      border-radius: 14px; /* subtle rounding for the cut edge */
      /* No background on purpose: this element only controls glow clipping. */
    }
    .bloom-clipper.unclipped{
      overflow: visible; /* allow bloom to spill naturally */
    }

    .countdown-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: transform 650ms var(--ease-smooth), top 650ms var(--ease-smooth), filter 240ms var(--ease-smooth);
      position: relative;
      top: -5px; /* Fine-tuned for better alignment */
      filter: blur(var(--focusBlur)) saturate(var(--focusSat)) brightness(var(--focusBri)) drop-shadow(0 0 calc(var(--bloom) * 1px) rgba(255,255,255,var(--bloomOpacityEff)));
      will-change: transform;
    }
    .countdown-wrapper.centered {
      transform: translate3d(0, 0, 0);
    }

    .title {
      font-size: 1.5rem;
      margin-bottom: 20px;

      /* When the title is hidden, we collapse its space so the countdown stays truly centered */
      max-height: 2.6em;
      overflow: hidden;

      transition:
        opacity 500ms var(--ease-smooth),
        transform 500ms var(--ease-smooth),
        max-height 500ms var(--ease-smooth),
        margin-bottom 500ms var(--ease-smooth);
      transform: translate3d(0, 0, 0);
      will-change: opacity, transform, max-height, margin-bottom;
    }
    .title.hidden {
      opacity: 0;
      transform: translate3d(0, -8px, 0);
      max-height: 0;
      margin-bottom: 0;
      pointer-events: none;
    }

    .countdown {
      font-size: 3rem;
      margin-bottom: 40px;
      font-weight: 400;
      transition: font-weight 250ms var(--ease-smooth);
      will-change: opacity, transform, filter;
      transform: translate3d(0,0,0);
      opacity: 1;
      animation: countdown-enter 800ms var(--ease-smooth) both;
    }

    @keyframes countdown-enter {
      from { opacity: 0; transform: translate3d(0, 10px, 0) scale(0.98); }
      to   { opacity: 1; transform: translate3d(0, 0, 0) scale(1); }
    }

    .countdown.thin { font-weight: 200; }

    .control-panel {
      position: fixed;
      bottom: 0;
      left: 0;
      background: var(--theme-panel);
      color: #ffffff;
      padding: 10px;
      border-top-right-radius: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 60;
      transition: transform 450ms var(--ease-smooth), opacity 450ms var(--ease-smooth);
      will-change: transform, opacity;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .control-panel.hidden {
      transform: translate3d(calc(-100% - 12px), 0, 0);
      opacity: 0;
      pointer-events: none;
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.9rem;
    }

    input[type="range"], input[type="number"] { width: 150px; }
    input[type="number"] {
      width: 60px;
      background: #333;
      color: #fff;
      border: 1px solid #555;
      border-radius: 3px;
      padding: 3px;
      transition: border-color 200ms ease, transform 200ms var(--ease-smooth);
    }
    input[type="number"]:focus-visible { outline: none; border-color: rgba(255,255,255,0.7); }

    .buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    button {
      background-color: rgba(255, 255, 255, 0.2);
      color: #ffffff;
      border: 1px solid color-mix(in srgb, var(--theme-accent) 68%, white 32%);
      padding: 6px 10px;
      font-size: 0.9rem;
      cursor: pointer;
      border-radius: 8px;
      transition: background-color 200ms ease, transform 200ms var(--ease-smooth), border-color 200ms ease;
      will-change: transform;
    }
    button:hover { background-color: rgba(255, 255, 255, 0.35); transform: translate3d(0, -1px, 0); }
    button:active { transform: translate3d(0, 0, 0) scale(0.98); }
    button:focus-visible { outline: 2px solid rgba(255,255,255,0.55); outline-offset: 2px; }

    .toggle-arrow {
      position: fixed;
      bottom: 50%;
      left: 10px;
      transform: translateY(-50%);
      background: rgba(255, 255, 255, 0.2);
      color: #ffffff;
      border: none;
      padding: 10px 15px;
      border-radius: 10px;
      cursor: pointer;
      z-index: 20;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 450ms var(--ease-smooth), background-color 200ms ease;
      will-change: transform;
      user-select: none;
    }
    .toggle-arrow:hover { background: rgba(255,255,255,0.32); }
    .toggle-arrow.bump { transform: translateY(-50%) translate3d(2px, 0, 0); }

    /* Respect reduced-motion settings */
    @media (prefers-reduced-motion: reduce) {
      * { transition: none !important; animation: none !important; }
    }
  

    /* ===== Settings UI refresh ===== */
    .control-panel{
      width: min(380px, calc(100vw - 24px));
      max-height: calc(100vh - 18px);
      overflow: auto;
      padding: 14px 14px 12px;
      border-top-right-radius: 16px;
      border: 1px solid var(--theme-border);
      background:
        radial-gradient(1200px 450px at 20% 0%, color-mix(in srgb, var(--theme-accent) 22%, transparent), transparent 45%),
        linear-gradient(180deg, color-mix(in srgb, var(--theme-panel) 74%, rgba(255,255,255,0.10)), color-mix(in srgb, var(--theme-panel) 92%, rgba(0,0,0,0.24)));
      box-shadow: inset 0 0 0 1px var(--theme-soft), 0 24px 58px rgba(0,0,0,0.36);
      backdrop-filter: blur(14px) saturate(1.15);
      -webkit-backdrop-filter: blur(14px) saturate(1.15);
    }
    .control-panel::-webkit-scrollbar{ width: 10px; }
    .control-panel::-webkit-scrollbar-thumb{
      background: rgba(255,255,255,0.14);
      border-radius: 12px;
      border: 2px solid rgba(0,0,0,0.22);
    }
    .control-panel::-webkit-scrollbar-track{ background: transparent; }

    .settings-header{
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: start;
      gap: 12px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      margin-bottom: 10px;
    }
    #resetSettings{ justify-self: end; }

    .settings-title{
      justify-self: center;
      text-align: center;
      display: flex;
      align-items: center;
      gap: 10px;
      justify-content: center;
      min-width: 0;
    }
    .settings-icon{
      width: 34px; height: 34px;
      display: grid; place-items: center;
      border-radius: 12px;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.16);
      box-shadow: 0 10px 24px rgba(0,0,0,0.18);
      flex: 0 0 auto;
    }
    .settings-h1{
      font-weight: 700;
      letter-spacing: -0.015em;
      font-size: 14px;
      line-height: 1.1;
      margin: 0;
    }
    .settings-sub{
      font-size: 12px;
      opacity: 0.78;
      line-height: 1.25;
      margin-top: 3px;
      max-width: 240px;
    }

    .settings-section{ display: flex; flex-direction: column; gap: 8px; margin-top: 10px; }
    .section-title{
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      opacity: 0.72;
      margin-top: 2px;
    }
    .section-note{
      font-size: 12px;
      opacity: 0.72;
      line-height: 1.25;
      margin-top: -2px;
    }

    .setting-row, .slider-row{
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto;
      gap: 10px;
      align-items: start;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid color-mix(in srgb, var(--theme-border) 82%, rgba(255,255,255,0.18));
      background: linear-gradient(180deg, color-mix(in srgb, var(--theme-panel) 72%, rgba(255,255,255,0.10)), color-mix(in srgb, var(--theme-panel) 90%, rgba(0,0,0,0.20)));
      box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--theme-soft) 88%, rgba(255,255,255,0.04));
    }
    .setting-meta{ min-width: 0; }
    .setting-name{
      font-size: 13px;
      font-weight: 650;
      letter-spacing: -0.01em;
      line-height: 1.1;
    }
    .setting-desc{
      margin-top: 3px;
      font-size: 12px;
      opacity: 0.78;
      line-height: 1.25;
      overflow-wrap: anywhere;
      text-wrap: pretty;
    }

    .control-panel .btn{
      border: 1px solid color-mix(in srgb, var(--theme-border) 82%, rgba(255,255,255,0.20));
      background: linear-gradient(180deg, color-mix(in srgb, var(--theme-panel) 70%, rgba(255,255,255,0.14)), color-mix(in srgb, var(--theme-panel) 88%, rgba(0,0,0,0.18)));
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 12px;
      line-height: 1.1;
      box-shadow: 0 10px 24px rgba(0,0,0,0.16), inset 0 0 0 1px color-mix(in srgb, var(--theme-soft) 80%, rgba(255,255,255,0.04));
      white-space: normal;
    }
    .control-panel .btn:hover{
      background: linear-gradient(180deg, color-mix(in srgb, var(--theme-panel) 64%, rgba(255,255,255,0.20)), color-mix(in srgb, var(--theme-panel) 84%, rgba(0,0,0,0.15)));
      border-color: color-mix(in srgb, var(--theme-accent) 48%, white 52%);
      transform: translate3d(0,-1px,0);
    }
    .control-panel .btn:active{ transform: translate3d(0,0,0) scale(0.985); }

    .control-panel .btn.ghost{
      background: linear-gradient(180deg, color-mix(in srgb, var(--theme-panel) 76%, rgba(255,255,255,0.07)), color-mix(in srgb, var(--theme-panel) 92%, rgba(0,0,0,0.20)));
      box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--theme-soft) 70%, rgba(255,255,255,0.03));
    }
    .control-panel .btn.toggle-btn{ min-width: 150px; justify-self: end; }

    .setting-row > .dropdown,
    .setting-row > .btn,
    .setting-row > .toggle-btn,
    .slider-row > .slider-controls{
      align-self: center;
    }

    .slider-controls{
      display: grid;
      grid-template-columns: 170px 78px;
      gap: 10px;
      align-items: center;
      justify-items: end;
    }
    .slider-controls input[type="range"]{
      width: 170px;
      accent-color: rgba(255,255,255,0.92);
    }
    .control-panel input[type="number"]{
      width: 78px;
      background: rgba(0,0,0,0.30);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 10px;
      padding: 7px 8px;
    }
    .control-panel input[type="number"]:focus-visible{
      outline: 2px solid rgba(255,255,255,0.38);
      outline-offset: 2px;
    }

    .control-panel .ui-select{
      width: 170px;
      background: linear-gradient(180deg, color-mix(in srgb, var(--theme-panel) 82%, transparent), color-mix(in srgb, var(--theme-panel) 94%, black));
      color: var(--theme-text);
      border: 1px solid var(--theme-border);
      border-radius: 12px;
      padding: 8px 12px;
      font-size: 12px;
      line-height: 1.1;
      box-shadow: 0 10px 24px rgba(0,0,0,0.22), inset 0 0 0 1px var(--theme-soft);
      appearance: none;
      -webkit-appearance: none;
      cursor: pointer;
      transition: transform 200ms var(--ease-smooth), border-color 200ms var(--ease-smooth), box-shadow 220ms var(--ease-smooth), background 220ms var(--ease-smooth);
      background-image:
        linear-gradient(45deg, transparent 50%, color-mix(in srgb, var(--theme-accent) 70%, white 30%) 50%),
        linear-gradient(135deg, color-mix(in srgb, var(--theme-accent) 70%, white 30%) 50%, transparent 50%);
      background-position:
        calc(100% - 16px) calc(50% - 2px),
        calc(100% - 10px) calc(50% - 2px);
      background-size: 6px 6px, 6px 6px;
      background-repeat: no-repeat;
    }
    .control-panel .ui-select:hover{
      transform: translateY(-1px);
      border-color: color-mix(in srgb, var(--theme-accent) 55%, white 45%);
      box-shadow: 0 14px 28px rgba(0,0,0,0.28), inset 0 0 0 1px color-mix(in srgb, var(--theme-accent) 28%, transparent);
    }
    .control-panel .ui-select:focus-visible{
      outline: 2px solid color-mix(in srgb, var(--theme-accent) 46%, white 54%);
      outline-offset: 2px;
    }


    /* Range slider styling with filled track (matches the rest of the UI) */
    .control-panel input[type="range"]{
      --p: 0;
      -webkit-appearance: none;
      appearance: none;
      height: 28px;
      background: transparent;
      cursor: pointer;
      padding: 0;
      margin: 0;
      outline: none;
    }
    .control-panel input[type="range"]::-webkit-slider-runnable-track{
      height: 7px;
      border-radius: 999px;
      background: linear-gradient(90deg,
        rgba(255,255,255,0.92) 0%,
        rgba(255,255,255,0.86) calc(var(--p)*1%),
        rgba(255,255,255,0.20) calc(var(--p)*1%),
        rgba(255,255,255,0.20) 100%);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.12);
    }
    .control-panel input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      background: rgba(255,255,255,0.92);
      border: 1px solid rgba(0,0,0,0.26);
      margin-top: -5.5px;
      box-shadow: 0 8px 18px rgba(0,0,0,0.35);
      transition: transform 140ms var(--ease-smooth), box-shadow 140ms var(--ease-smooth);
    }
    .control-panel input[type="range"]:active::-webkit-slider-thumb{
      transform: scale(1.12);
      box-shadow: 0 10px 22px rgba(0,0,0,0.42);
    }
    .control-panel input[type="range"]:focus-visible::-webkit-slider-thumb{
      box-shadow: 0 0 0 4px rgba(255,255,255,0.18), 0 8px 18px rgba(0,0,0,0.35);
    }

    .control-panel input[type="range"]::-moz-range-track{
      height: 7px;
      border-radius: 999px;
      background: rgba(255,255,255,0.20);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.12);
    }
    .control-panel input[type="range"]::-moz-range-progress{
      height: 7px;
      border-radius: 999px;
      background: rgba(255,255,255,0.86);
    }
    .control-panel input[type="range"]::-moz-range-thumb{
      width: 18px;
      height: 18px;
      border-radius: 999px;
      background: rgba(255,255,255,0.92);
      border: 1px solid rgba(0,0,0,0.26);
      box-shadow: 0 8px 18px rgba(0,0,0,0.35);
      transition: transform 140ms var(--ease-smooth), box-shadow 140ms var(--ease-smooth);
    }
    .control-panel input[type="range"]:active::-moz-range-thumb{
      transform: scale(1.12);
      box-shadow: 0 10px 22px rgba(0,0,0,0.42);
    }

    .preset-grid{
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
    }
    .control-panel .btn.preset{
      justify-self: stretch;
      text-align: center;
      padding: 9px 10px;
    }

    .settings-footer{
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.10);
      font-size: 12px;
      opacity: 0.78;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .kbd{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 22px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.25);
      font-size: 11px;
      line-height: 1.1;
      opacity: 0.95;
    }

    /* Make the side toggle button feel more "buttony" */
    .toggle-arrow{
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(10px) saturate(1.1);
      -webkit-backdrop-filter: blur(10px) saturate(1.1);
      box-shadow: 0 10px 26px rgba(0,0,0,0.22);
    }

  
    .settings-backdrop{
      position: fixed;
      inset: 0;
      z-index: 50;
      opacity: 0;
      pointer-events: none;
      background: rgba(0,0,0,0.25);
      backdrop-filter: blur(14px) saturate(110%);
      transition: opacity 220ms var(--ease-smooth);
      will-change: opacity;
    }
    body.settings-open .settings-backdrop{
      opacity: 1;
      pointer-events: auto;
    }
    body.settings-open{
      --focusBlur: 10px;
      --focusSat: 0.92;
      --focusBri: 0.88;
    }

    body.settings-open #countdownWrapper{
      transform: translate3d(0, -15%, 0) scale(0.995);
      transition: filter 240ms var(--ease-smooth), transform 240ms var(--ease-smooth);
      will-change: filter, transform;
    }
    
    .countdown{
      display: inline-flex;
      align-items: baseline;
      gap: 0.55ch;
      line-height: 1;
    }
    .cd-unit{
      display: inline-flex;
      align-items: baseline;
      gap: 0.35ch;

      /* Animated hide/show (we collapse first, then JS toggles display:none at the end) */
      overflow: hidden;
      max-width: 24ch;
      opacity: 1;
      transform: translate3d(0,0,0);
      transition:
        opacity 260ms var(--ease-smooth),
        transform 260ms var(--ease-smooth),
        max-width 260ms var(--ease-smooth);
      will-change: opacity, transform, max-width;
    }
    .cd-unit.is-hidden{
      opacity: 0;
      transform: translate3d(0,-6px,0);
      max-width: 0;
      pointer-events: none;
    }

    .cd-sep{
      transition: opacity 220ms var(--ease-smooth), transform 220ms var(--ease-smooth);
      will-change: opacity, transform;
    }
    .cd-sep.is-hidden{
      opacity: 0;
      transform: translate3d(0,-4px,0);
      pointer-events: none;
    }
    .cd-value{
      letter-spacing: 0.01em;
    }
    .cd-label{
      font-size: 0.34em;
      opacity: 0.74;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }
    .cd-sep{
      opacity: 0.62;
      transform: translate3d(0, -0.02em, 0);
    }
    /* Default: verbose mode (labels visible, colons hidden) */
    .countdown .cd-sep--colon{ display:none; }
    .countdown.verbose{ gap: 0.75ch; }
    .countdown.verbose .cd-sep--colon{ display:none; }
    /* Condensed: labels hidden, colons shown */
    .countdown.condensed{ gap: 0.18ch; }
    .countdown.condensed .cd-label{ display:none; }
    .countdown.condensed .cd-sep--colon{ display:inline; }

    /* Unit label toggle (independent of condensed mode) */
    .countdown.labels-off{ gap: 0.18ch; }
    .countdown.labels-off .cd-label{ display:none; }
    .countdown.labels-off .cd-sep--colon{ display:inline; }

    .countdown.labels-on{ gap: 0.75ch; }
    .countdown.labels-on .cd-sep--colon{ display:none; }
    
    @keyframes seconds-tick{
      0%   { opacity: 1; transform: translate3d(0,0,0); }
      45%  { opacity: 0; transform: translate3d(0,-4px,0); }
      55%  { opacity: 0; transform: translate3d(0,4px,0); }
      100% { opacity: 1; transform: translate3d(0,0,0); }
    }
    .cd-seconds.sec-tick{
      animation: seconds-tick 340ms var(--ease-smooth) both;
    }
    @media (prefers-reduced-motion: reduce){
      .cd-seconds.sec-tick{ animation: none !important; }
    }
    
    /* ===== Multi-countdown (tasks) UI ===== */
    .status-line{
      margin-top: -26px;
      margin-bottom: 14px;
      font-size: 13px;
      line-height: 1.35;
      opacity: 0.85;
      max-width: min(680px, calc(100vw - 32px));
      padding: 0 10px;
      text-wrap: pretty;
    }
    .status-line .pill{
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.22);
      backdrop-filter: blur(10px) saturate(1.12);
      -webkit-backdrop-filter: blur(10px) saturate(1.12);
      box-shadow: 0 10px 26px rgba(0,0,0,0.18);
      margin: 6px 6px 0 0;
      white-space: nowrap;
    }

    .pill-link{
      color: inherit;
      text-decoration: none;
      cursor: pointer;
    }
    .pill-link:hover{
      background: rgba(255,255,255,0.10);
      border-color: rgba(255,255,255,0.22);
    }
    .task-actions{
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: -6px;
    }
    .task-btn{
      background-color: rgba(255, 255, 255, 0.18);
      color: #ffffff;
      border: 1px solid rgba(255, 255, 255, 0.85);
      padding: 7px 12px;
      font-size: 0.9rem;
      cursor: pointer;
      border-radius: 10px;
      transition: background-color 200ms ease, transform 200ms var(--ease-smooth), border-color 200ms ease, opacity 200ms ease;
    }
    .task-btn:hover { background-color: rgba(255, 255, 255, 0.30); transform: translate3d(0, -1px, 0); }
    .task-btn:active { transform: translate3d(0, 0, 0) scale(0.985); }
    .task-btn.ghost{
      background-color: rgba(0, 0, 0, 0.18);
      border-color: rgba(255,255,255,0.38);
      opacity: 0.92;
    }
    .task-btn[disabled]{ opacity: 0.45; cursor: not-allowed; transform: none !important; }

    /* Settings panel: task form + list */
    .task-form{
      display: grid;
      grid-template-columns: 1fr 170px auto;
      gap: 8px;
      align-items: center;
      margin-top: 6px;
    }
    @media (max-width: 420px){
      .task-form{ grid-template-columns: 1fr; }
    }
    
    .task-input{
      width: 100%;
      background: rgba(0,0,0,0.30);
      color: rgba(255,255,255,0.92);
      -webkit-text-fill-color: rgba(255,255,255,0.92);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 13px;
      outline: none;
      transition:
        background-color 200ms var(--ease-smooth),
        border-color 200ms var(--ease-smooth),
        box-shadow 200ms var(--ease-smooth),
        transform 200ms var(--ease-smooth);
      color-scheme: dark;
    }
    .task-input:hover{
      background: rgba(0,0,0,0.36);
      border-color: rgba(255,255,255,0.22);
    }
    .task-input:focus{
      border-color: rgba(255,255,255,0.30);
      box-shadow: 0 0 0 3px rgba(255,255,255,0.06);
    }
    .task-input:focus-visible{
      outline: 2px solid rgba(255,255,255,0.38);
      outline-offset: 2px;
    }
    input[type="datetime-local"].task-input::-webkit-calendar-picker-indicator{
      filter: invert(1);
      opacity: 0.85;
    }


    .task-list{
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .task-row{
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
    }
    .task-row.is-active{
      border-color: rgba(255,255,255,0.24);
      background: rgba(255,255,255,0.09);
      box-shadow: 0 12px 28px rgba(0,0,0,0.18);
    }
    .task-row .task-main{
      min-width: 0;
    }
    .task-row .task-title{
      font-size: 13px;
      font-weight: 650;
      letter-spacing: -0.01em;
      line-height: 1.15;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .task-row .task-sub{
      margin-top: 3px;
      font-size: 12px;
      opacity: 0.78;
      line-height: 1.25;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .task-row .badge{
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.18);
      font-size: 11px;
      opacity: 0.92;
    }
    .task-row .task-actions-mini{
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: end;
    }
    .task-row .mini-btn{
      padding: 6px 9px;
      border-radius: 10px;
      font-size: 12px;
    }

    
    
    /* === v9: manual reorder (same due date/time) === */
    .task-row .task-left{
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }
    .drag-handle{
      width: 18px;
      height: 22px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.10);
      color: rgba(255,255,255,0.72);
      font-size: 12px;
      line-height: 1;
      user-select: none;
      cursor: grab;
    }
    .drag-handle:active{ cursor: grabbing; }
    .drag-handle[aria-disabled="true"]{
      opacity: 0.25;
      cursor: default;
    }
    .task-row.dragging{
      opacity: 0.75;
      border-color: rgba(255,255,255,0.18);
    }
    .task-row.drag-over{
      border-color: rgba(255,255,255,0.28);
      background: rgba(255,255,255,0.10);
    }
/* ---- Added: startup save/restore, extra hide toggles, preset highlight, toast ---- */
    .status-line{
      overflow: hidden;
      max-height: 120px;
      transition:
        opacity 260ms var(--ease-smooth),
        transform 260ms var(--ease-smooth),
        max-height 260ms var(--ease-smooth),
        margin 260ms var(--ease-smooth);
      will-change: opacity, transform, max-height, margin;
    }
    .status-line.collapsed{
      opacity: 0;
      transform: translate3d(0,-6px,0);
      max-height: 0;
      margin-top: 0;
      margin-bottom: 0;
      pointer-events: none;
    }

    .task-actions{
      overflow: hidden;
      max-height: 90px;
      transition:
        opacity 260ms var(--ease-smooth),
        transform 260ms var(--ease-smooth),
        max-height 260ms var(--ease-smooth),
        margin 260ms var(--ease-smooth);
      will-change: opacity, transform, max-height, margin;
    }
    .task-actions.collapsed{
      opacity: 0;
      transform: translate3d(0,-6px,0);
      max-height: 0;
      margin-top: 0;
      pointer-events: none;
    }

    .btn.preset.is-active{
      border-color: rgba(255,255,255,0.92);
      box-shadow:
        0 0 0 2px rgba(255,255,255,0.12) inset,
        0 12px 24px rgba(0,0,0,0.35);
    }

    .settings-header .header-actions{
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translate3d(-50%, 10px, 0);
      background: rgba(0,0,0,0.62);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.18);
      padding: 10px 14px;
      border-radius: 14px;
      backdrop-filter: blur(10px);
      opacity: 0;
      pointer-events: none;
      z-index: 9999;
      transition: opacity 200ms var(--ease-smooth), transform 200ms var(--ease-smooth);
      max-width: min(520px, calc(100vw - 28px));
      text-align: center;
      font-size: 13px;
      line-height: 1.25;
    }
    .toast.show{
      opacity: 1;
      transform: translate3d(-50%, 0, 0);
    }

  

    /* ===== Import / Export ===== */
    .import-box{
      margin-top: 14px;
      padding: 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      text-align: left;
    }
    .import-title{
      font-weight: 700;
      letter-spacing: 0.2px;
      margin-bottom: 6px;
    }
    .import-note{
      font-size: 12px;
      line-height: 1.35;
      opacity: 0.92;
      margin-bottom: 10px;
    }
    .import-hint{ opacity: 0.85; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .task-textarea{
      width: 100%;
      min-height: 132px;
      resize: vertical;
      padding: 10px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.22);
      color: rgba(255,255,255,0.95);
      outline: none;
      font-size: 12px;
      line-height: 1.35;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    .task-textarea:focus{
      border-color: rgba(255,255,255,0.28);
      box-shadow: 0 0 0 3px rgba(255,255,255,0.06);
    }
    .import-options{
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      margin-top: 10px;
      margin-bottom: 10px;
    }
    .check{
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      opacity: 0.92;
      user-select: none;
    }
    .check input{ accent-color: rgba(255,255,255,0.9); }
    .import-actions{
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-start;
    }


    /* === v4 additions: celebration dropdown + modals + confetti === */
    .btn.danger{ border-color: rgba(255,120,120,0.35); background: rgba(255,120,120,0.12); }
    .btn.danger:hover{ background: rgba(255,120,120,0.18); }

    .confetti-canvas{
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 13000;
      opacity: 0;
      transition: opacity 180ms var(--ease-smooth);
    }
    .confetti-canvas.is-on{ opacity: 1; }

    .dropdown{ position: relative; display: inline-flex; justify-content: flex-end; width: 100%; }
    .dropdown-btn{ width: 100%; justify-content: space-between; gap: 12px; padding-right: 14px; }
    .dropdown-btn::after{ content: "▾"; opacity: .85; transform: translateY(-1px); transition: transform 160ms var(--ease-smooth); }
    .dropdown.open .dropdown-btn::after{ transform: rotate(180deg) translateY(0px); }

    .dropdown-menu{
      position: absolute;
      right: 0;
      top: calc(100% + 10px);
      min-width: 260px;
      padding: 8px;
      border-radius: 16px;
      border: 1px solid var(--theme-border);
      background: rgba(20,23,33,0.74);
      background: linear-gradient(180deg, color-mix(in srgb, var(--theme-panel) 74%, rgba(255,255,255,0.08)), color-mix(in srgb, var(--theme-panel) 90%, rgba(0,0,0,0.2)));
      backdrop-filter: blur(16px) saturate(1.1);
      box-shadow: 0 20px 64px rgba(0,0,0,0.45), inset 0 0 0 1px var(--theme-soft);
      transform-origin: top right;
      opacity: 0;
      transform: translateY(-10px) scale(0.982);
      pointer-events: none;
      transition: opacity 220ms var(--ease-smooth), transform 220ms var(--ease-smooth), border-color 220ms var(--ease-smooth);
      z-index: 10050;
    }
    .dropdown.open .dropdown-menu{
      opacity: 1;
      transform: translateY(0) scale(1);
      pointer-events: auto;
    }
    .dropdown-item{
      width: 100%;
      border: 0;
      background: transparent;
      color: inherit;
      border-radius: 14px;
      padding: 10px 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      text-align: left;
    }
    .dropdown-item span:first-child{
      min-width: 0;
      overflow-wrap: anywhere;
    }

    @media (max-width: 720px){
      .setting-row,
      .slider-row,
      .task-row{
        grid-template-columns: 1fr;
      }
      .control-panel .btn.toggle-btn,
      .slider-controls{
        justify-self: stretch;
      }
      .slider-controls{
        width: 100%;
        grid-template-columns: minmax(0, 1fr) 78px;
      }
      .slider-controls input[type="range"],
      .control-panel .ui-select{
        width: 100%;
      }
      .dropdown-menu{
        left: 0;
        right: auto;
        min-width: 100%;
      }
    }
    .dropdown-item:hover{ background: var(--theme-soft); transform: translateX(2px); }
    .dropdown-item .check{ opacity: 0; transition: opacity 120ms var(--ease-smooth); }
    .dropdown-item[aria-selected="true"]{ background: color-mix(in srgb, var(--theme-accent) 20%, transparent); border:1px solid color-mix(in srgb, var(--theme-accent) 35%, transparent); }
    .dropdown-item[aria-selected="true"] .check{ opacity: 1; }

    
    /* v6: Background picker sub-panels */
    .bg-panel{
      margin-top: 10px;
      padding: 10px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      overflow: hidden;
      max-height: 0;
      opacity: 0;
      transform: translate3d(0,-6px,0);
      pointer-events: none;
      transition:
        max-height 260ms var(--ease-smooth),
        opacity 260ms var(--ease-smooth),
        transform 260ms var(--ease-smooth);
    }
    .bg-panel.show{
      max-height: 260px;
      opacity: 1;
      transform: translate3d(0,0,0);
      pointer-events: auto;
    }
    .bg-panel .row{
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .bg-panel .row > *{
      flex: 1 1 220px;
      min-width: 180px;
    }
    .bg-panel .row .btn{
      flex: 0 0 auto;
      min-width: 120px;
    }
    .bg-panel .note{
      margin-top: 8px;
      font-size: 12px;
      opacity: 0.88;
      line-height: 1.35;
    }
    .bg-panel .note a{ color: rgba(255,255,255,0.92); }
    .bg-nav{
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    .unsplash-credit{
      position: fixed;
      left: 16px;
      bottom: 16px;
      z-index: 40;
      max-width: min(520px, calc(100vw - 32px));
      font-size: 12px;
      line-height: 1.35;
      color: rgba(255,255,255,0.80);
      background: rgba(0,0,0,0.36);
      border: 1px solid rgba(255,255,255,0.14);
      padding: 8px 10px;
      border-radius: 14px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 14px 34px rgba(0,0,0,0.35);
      transition: opacity 180ms var(--ease-smooth), transform 180ms var(--ease-smooth);
      opacity: 0.0;
      transform: translateY(6px);
      pointer-events: none;
    }
    .unsplash-credit.show{
      opacity: 1.0;
      transform: translateY(0);
      pointer-events: auto;
    }
    .unsplash-credit a{
      color: rgba(255,255,255,0.92);
      text-decoration: none;
      border-bottom: 1px solid rgba(255,255,255,0.28);
    }
    .unsplash-credit a:hover{
      border-bottom-color: rgba(255,255,255,0.60);
    }
    body.settings-open .unsplash-credit{
      opacity: 0 !important;
      pointer-events: none !important;
      transform: translateY(8px);
    }

    body.theme-shift *{
      transition: color 340ms var(--ease-smooth), background-color 340ms var(--ease-smooth), border-color 340ms var(--ease-smooth), box-shadow 340ms var(--ease-smooth), filter 340ms var(--ease-smooth) !important;
    }

    .top-error{
      position: fixed;
      top: 14px;
      left: 50%;
      transform: translate3d(-50%, -140%, 0);
      z-index: 15000;
      background: rgba(191,30,48,0.95);
      color:#fff;
      border:1px solid rgba(255,255,255,0.35);
      padding: 10px 14px;
      border-radius: 12px;
      box-shadow: 0 14px 30px rgba(0,0,0,0.35);
      transition: transform 280ms var(--ease-smooth), opacity 280ms var(--ease-smooth);
      opacity:0;
      pointer-events:none;
      font-size:13px;
    }
    .top-error.show{ transform: translate3d(-50%,0,0); opacity:1; }

    .trello-import-tab{ max-height: 44vh; overflow:auto; padding:10px; border:1px solid var(--theme-border); border-radius:14px; background: rgba(28,31,42,0.62); background: linear-gradient(180deg, color-mix(in srgb, var(--theme-panel) 72%, rgba(255,255,255,0.08)), color-mix(in srgb, var(--theme-panel) 88%, rgba(0,0,0,0.18))); box-shadow: inset 0 0 0 1px var(--theme-soft), 0 10px 30px rgba(0,0,0,0.26); }
    .trello-list{ border:1px solid var(--theme-border); border-radius:12px; margin-bottom:8px; overflow:hidden; background: rgba(255,255,255,0.04); transition:border-color 180ms var(--ease-smooth), transform 180ms var(--ease-smooth), box-shadow 180ms var(--ease-smooth), background 180ms var(--ease-smooth); }
    .trello-list:hover{ border-color: color-mix(in srgb, var(--theme-accent) 45%, white 55%); transform: translateY(-1px); box-shadow: inset 0 0 0 1px var(--theme-soft); }
    .trello-list-head{ display:flex; align-items:center; gap:8px; padding:9px 10px; background: rgba(255,255,255,0.06); background: linear-gradient(180deg, color-mix(in srgb, var(--theme-panel) 74%, rgba(255,255,255,0.09)), color-mix(in srgb, var(--theme-panel) 88%, rgba(0,0,0,0.2))); cursor:pointer; }
    .trello-arrow{ display:inline-block; transition:transform 180ms var(--ease-smooth); }
    .trello-list.open .trello-arrow{ transform: rotate(90deg); }
    .trello-cards{ max-height:0; overflow:hidden; transition:max-height 260ms var(--ease-smooth); padding:0 10px; display:grid; gap:8px; }
    .trello-list.open .trello-cards{ max-height:280px; padding:10px; }
    .trello-card{ font-size:12px; opacity:.96; text-align:left; padding:8px 10px; border-radius:10px; border:1px solid color-mix(in srgb, var(--theme-border) 70%, rgba(255,255,255,0.24)); background: linear-gradient(180deg, rgba(255,255,255,0.11), rgba(255,255,255,0.03)); box-shadow: 0 6px 16px rgba(0,0,0,0.24), inset 0 0 0 1px rgba(255,255,255,0.03); display:grid; gap:4px; }
    .trello-card-title{ font-weight:600; letter-spacing:-0.01em; line-height:1.2; }
    .trello-card-meta{ font-size:11px; opacity:0.78; }
    .settings-advanced{ margin-top:8px; border:1px solid color-mix(in srgb, var(--theme-border) 82%, rgba(255,255,255,0.18)); border-radius:14px; padding:6px 10px; background: linear-gradient(180deg, color-mix(in srgb, var(--theme-panel) 72%, rgba(255,255,255,0.10)), color-mix(in srgb, var(--theme-panel) 90%, rgba(0,0,0,0.20))); box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--theme-soft) 88%, rgba(255,255,255,0.04)); transition:border-color 220ms var(--ease-smooth), box-shadow 220ms var(--ease-smooth), transform 220ms var(--ease-smooth), background 220ms var(--ease-smooth); }
    .settings-advanced:hover{ border-color: color-mix(in srgb, var(--theme-accent) 45%, white 55%); box-shadow: inset 0 0 0 1px var(--theme-soft), 0 10px 24px rgba(0,0,0,0.2); transform: translateY(-1px); }
    .settings-advanced > summary{ cursor:pointer; font-weight:600; list-style:none; display:flex; align-items:center; gap:8px; }
    .settings-advanced > summary::-webkit-details-marker{ display:none; }
    .settings-advanced > summary::before{ content:'▸'; opacity:.9; transition: transform 180ms var(--ease-smooth), color 180ms var(--ease-smooth); color: var(--theme-accent); }
    .settings-advanced[open] > summary::before{ transform: rotate(90deg); }
    .settings-advanced .import-options{ margin-top:10px; padding:8px; border-radius:10px; border:1px solid color-mix(in srgb, var(--theme-border) 74%, rgba(255,255,255,0.2)); background: linear-gradient(180deg, color-mix(in srgb, var(--theme-panel) 70%, rgba(255,255,255,0.10)), color-mix(in srgb, var(--theme-panel) 88%, rgba(0,0,0,0.18))); box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--theme-soft) 80%, rgba(255,255,255,0.03)); }
    .control-panel input[type="color"]{ width: 170px; height: 38px; border-radius: 12px; border:1px solid var(--theme-border); background: transparent; padding: 3px; box-shadow: 0 10px 22px rgba(0,0,0,0.18); cursor:pointer; transition: transform 200ms var(--ease-smooth), border-color 200ms var(--ease-smooth), box-shadow 200ms var(--ease-smooth); }
    .control-panel input[type="color"]:hover{ transform: translateY(-1px); border-color: color-mix(in srgb, var(--theme-accent) 55%, white 45%); box-shadow: 0 14px 26px rgba(0,0,0,0.25); }
    .theme-color-grid{ display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; width:100%; }
    .theme-swatch-label{ font-size:12px; opacity:.88; text-align:left; }
    .theme-card{ border:1px solid var(--theme-border); border-radius:14px; background: linear-gradient(180deg, color-mix(in srgb, var(--theme-panel) 78%, transparent), color-mix(in srgb, var(--theme-panel) 90%, black)); padding:10px; box-shadow: inset 0 0 0 1px var(--theme-soft); transition: transform 200ms var(--ease-smooth), border-color 200ms var(--ease-smooth); }
    .theme-card:hover{ transform: translateY(-1px); border-color: color-mix(in srgb, var(--theme-accent) 55%, white 45%); }


.modal-backdrop{
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.52);
      backdrop-filter: blur(10px);
      opacity: 0; pointer-events: none;
      transition: opacity 180ms var(--ease-smooth);
      z-index: 12000;
    }
    .modal-backdrop.show{ opacity: 1; pointer-events: auto; }

    .modal{
      position: fixed; left: 50%; top: 50%;
      width: min(560px, calc(100vw - 36px));
      transform: translate(-50%, -50%) scale(0.985);
      opacity: 0; pointer-events: none;
      transition: opacity 180ms var(--ease-smooth), transform 180ms var(--ease-smooth);
      z-index: 12001;
    }
    .modal.show{
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
      pointer-events: auto;
    }
    .modal-card{
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(14, 14, 18, 0.86);
      backdrop-filter: blur(16px);
      box-shadow: 0 24px 80px rgba(0,0,0,0.55);
      padding: 16px 16px 14px;
    }
    .modal-title{ font-weight: 750; letter-spacing: 0.2px; font-size: 16px; }
    .modal-message{
      margin-top: 8px;
      color: rgba(255,255,255,0.82);
      line-height: 1.45;
      font-size: 13px;
      white-space: pre-line;
    }
    .modal-actions{ margin-top: 14px; display: flex; gap: 10px; justify-content: flex-end; }
    .modal-form{ margin-top: 10px; }
    .modal-label{ display:block; margin-top:10px; margin-bottom:6px; font-size:12px; color: rgba(255,255,255,0.78); }

    .task-row.flash{ animation: taskFlash 760ms var(--ease-smooth) 1; }
    @keyframes taskFlash{
      0%{ box-shadow: 0 0 0 rgba(0,0,0,0); transform: scale(1); }
      35%{ box-shadow: 0 0 0 1px rgba(255,255,255,0.12), 0 18px 60px rgba(0,0,0,0.40); transform: scale(1.01); }
      100%{ box-shadow: 0 0 0 rgba(0,0,0,0); transform: scale(1); }
    }

</style>
</head>
<body>
  <!-- CountdownBeta_multi_tasks_v9: Manual reorder within same due date/time (saved) -->
  <div class="overlay" id="overlay"></div>
  <div class="settings-backdrop" id="settingsBackdrop" aria-hidden="true"></div>

  <div class="toast" id="toast" aria-live="polite" aria-atomic="true"></div>
  <div class="top-error" id="topError" aria-live="assertive" aria-atomic="true"></div>

  <!-- v4 additions: confetti + modals -->
  <canvas id="confettiCanvas" class="confetti-canvas" aria-hidden="true"></canvas>

  <div class="modal-backdrop" id="modalBackdrop" aria-hidden="true"></div>

  <div class="modal" id="confirmModal" role="dialog" aria-modal="true"
       aria-labelledby="confirmTitle" aria-describedby="confirmMessage" hidden>
    <div class="modal-card">
      <div class="modal-title" id="confirmTitle">Confirm</div>
      <div class="modal-message" id="confirmMessage"></div>
      <div class="modal-actions">
        <button class="btn ghost" id="confirmCancelBtn" type="button">Cancel</button>
        <button class="btn" id="confirmOkBtn" type="button">OK</button>
      </div>
    </div>
  </div>

  <div class="modal" id="editModal" role="dialog" aria-modal="true"
       aria-labelledby="editTaskTitle" hidden>
    <div class="modal-card">
      <div class="modal-title" id="editTaskTitle">Edit task</div>

      <div class="modal-form">
        <label class="modal-label" for="editTaskNameInput">Name</label>
        <input class="task-input" id="editTaskNameInput" type="text" placeholder="Task name">

        <label class="modal-label" for="editTaskDateInput" style="margin-top:10px;">
          Due date &amp; time
        </label>
        <input class="task-input" id="editTaskDateInput" type="datetime-local">
      </div>

      <div class="modal-actions">
        <button class="btn ghost" id="editCancelBtn" type="button">Cancel</button>
        <button class="btn" id="editSaveBtn" type="button">Save</button>
      </div>
    </div>
  </div>

  <div class="bloom-clipper" id="bloomClipper" data-clipped="true">
    <div class="countdown-wrapper" id="countdownWrapper">
    <h1 class="title" id="title">Countdown</h1>
    <div class="countdown" id="countdown" aria-live="polite" data-structured="true">
      <span class="cd-unit" data-unit="days" id="cdDaysUnit"><span class="cd-value" id="cdDays">0</span><span class="cd-label" id="cdDaysLabel">days</span></span><span class="cd-sep cd-sep--colon" id="sepDH" aria-hidden="true">:</span><span class="cd-unit" data-unit="hours" id="cdHoursUnit"><span class="cd-value" id="cdHours">00</span><span class="cd-label" id="cdHoursLabel">hours</span></span><span class="cd-sep cd-sep--colon" id="sepHM" aria-hidden="true">:</span><span class="cd-unit" data-unit="minutes" id="cdMinutesUnit"><span class="cd-value" id="cdMinutes">00</span><span class="cd-label" id="cdMinutesLabel">minutes</span></span><span class="cd-sep cd-sep--colon" id="sepMS" aria-hidden="true">:</span><span class="cd-unit" data-unit="seconds" id="cdSecondsUnit"><span class="cd-value cd-seconds" id="cdSeconds">00</span><span class="cd-label" id="cdSecondsLabel">seconds</span></span>
    </div>
      <div class="status-line" id="statusLine" aria-live="polite"></div>
      <div class="task-actions" id="taskActions" aria-label="Countdown actions">
        <button class="task-btn" id="completeTaskBtn" title="Mark the current countdown as completed">Mark completed</button>
        <button class="task-btn ghost" id="skipTaskBtn" title="Move past this countdown without completing it">Skip</button>
        <button class="task-btn ghost" id="catchUpBtn" title="Go through missed countdowns">Catch-up</button>
        <button class="task-btn ghost" id="undoLastBtn" title="Undo your most recent completion or skip">Undo</button>
      </div>
    </div>
  </div>

    <div class="control-panel hidden" id="controlPanel" role="region" aria-label="Settings panel">
    <div class="settings-header">
      <div class="settings-title">
        <div class="settings-icon" aria-hidden="true">⚙</div>
        <div>
          <div class="settings-h1">Settings</div>
          <div class="settings-sub">Visibility, formatting, and visual effects.</div>
        </div>
      </div>
      <div class="header-actions">
      <button class="btn ghost" id="saveStartupSettings" title="Save your current look/visibility settings so they load next time">Save startup</button>
      <button class="btn ghost" id="resetSettings" title="Restore everything to the original defaults" style="display:none;">Restore defaults</button>
    </div>
    </div>

    <div class="settings-section">
      <div class="section-title">Display</div>

      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Days</div>
          <div class="setting-desc">Show or hide the days unit.</div>
        </div>
        <button class="btn toggle-btn" id="toggleDays" data-active="true" title="Toggle days">Hide Days</button>
      </div>

      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Hours</div>
          <div class="setting-desc">Show or hide the hours unit.</div>
        </div>
        <button class="btn toggle-btn" id="toggleHours" data-active="true" title="Toggle hours">Hide Hours</button>
      </div>

      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Minutes</div>
          <div class="setting-desc">Show or hide the minutes unit.</div>
        </div>
        <button class="btn toggle-btn" id="toggleMinutes" data-active="true" title="Toggle minutes">Hide Minutes</button>
      </div>

      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Seconds</div>
          <div class="setting-desc">Show or hide the seconds unit.</div>
        </div>
        <button class="btn toggle-btn" id="toggleSeconds" data-active="true" title="Toggle seconds">Hide Seconds</button>
      </div>

      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Title</div>
          <div class="setting-desc">Date label above the countdown.</div>
        </div>
        <button class="btn toggle-btn" id="toggleTitle" data-active="true" title="Toggle title">Hide Title</button>
      </div>

      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Status line</div>
          <div class="setting-desc">Show or hide the badges (active / completed / missed).</div>
        </div>
        <button class="btn toggle-btn" id="toggleStatusLine" data-active="true" title="Toggle status line">Hide Status Line</button>
      </div>

      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Action buttons</div>
          <div class="setting-desc">Show or hide Mark completed / Skip / Undo.</div>
        </div>
        <button class="btn toggle-btn" id="toggleActionButtons" data-active="true" title="Toggle action buttons">Hide Action Buttons</button>
      </div>
    </div>

    <div class="settings-section">
      <div class="section-title">Formatting</div>

      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Font</div>
          <div class="setting-desc">Pick a typeface for the countdown and title.</div>
        </div>
        <div class="dropdown" id="fontDropdown">
          <button class="btn dropdown-btn" id="fontBtn" type="button" aria-haspopup="listbox" aria-expanded="false">Inter</button>
          <div class="dropdown-menu" id="fontMenu" role="listbox" aria-label="Font family">
            <button class="dropdown-item" type="button" role="option" data-value="inter" aria-selected="true"><span>Inter</span><span class="check">✓</span></button>
            <button class="dropdown-item" type="button" role="option" data-value="system" aria-selected="false"><span>System UI</span><span class="check">✓</span></button>
            <button class="dropdown-item" type="button" role="option" data-value="poppins" aria-selected="false"><span>Poppins</span><span class="check">✓</span></button>
            <button class="dropdown-item" type="button" role="option" data-value="montserrat" aria-selected="false"><span>Montserrat</span><span class="check">✓</span></button>
            <button class="dropdown-item" type="button" role="option" data-value="space" aria-selected="false"><span>Space Grotesk</span><span class="check">✓</span></button>
            <button class="dropdown-item" type="button" role="option" data-value="mono" aria-selected="false"><span>JetBrains Mono</span><span class="check">✓</span></button>
            <button class="dropdown-item" type="button" role="option" data-value="serif" aria-selected="false"><span>Playfair Display</span><span class="check">✓</span></button>
          </div>
        </div>
      </div>


      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Font weight</div>
          <div class="setting-desc">Set countdown number thickness.</div>
        </div>
        <div class="dropdown" id="fontWeightDropdown">
          <button class="btn dropdown-btn" id="fontWeightBtn" type="button" aria-haspopup="listbox" aria-expanded="false">Normal</button>
          <div class="dropdown-menu" id="fontWeightMenu" role="listbox" aria-label="Font weight">
            <button class="dropdown-item" type="button" role="option" data-value="200" aria-selected="false"><span>Light</span><span class="check">✓</span></button>
            <button class="dropdown-item" type="button" role="option" data-value="400" aria-selected="true"><span>Normal</span><span class="check">✓</span></button>
            <button class="dropdown-item" type="button" role="option" data-value="600" aria-selected="false"><span>Semibold</span><span class="check">✓</span></button>
            <button class="dropdown-item" type="button" role="option" data-value="700" aria-selected="false"><span>Bold</span><span class="check">✓</span></button>
          </div>
        </div>
      </div>

      <details class="settings-advanced">
        <summary>Advanced status line controls</summary>
        <div class="import-options" style="margin-top:8px;">
          <label class="check"><input type="checkbox" id="statShowTask" checked> Current task</label>
          <label class="check"><input type="checkbox" id="statShowDue" checked> Due date</label>
          <label class="check"><input type="checkbox" id="statShowPending" checked> Pending</label>
          <label class="check"><input type="checkbox" id="statShowCompleted" checked> Completed</label>
          <label class="check"><input type="checkbox" id="statShowMissed" checked> Missed</label>
          <label class="check"><input type="checkbox" id="statShowTrello" checked> Trello link</label>
        </div>
      </details>

      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Unit labels</div>
          <div class="setting-desc">Show or hide words like “days / hours”. When hidden, colons appear.</div>
        </div>
        <button class="btn toggle-btn" id="toggleUnitLabels" data-active="true" title="Toggle unit labels">Hide Unit Labels</button>
      </div>

      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Window title</div>
          <div class="setting-desc">Shorter tab/title text (handy for streaming).</div>
        </div>
        <button class="btn toggle-btn" id="toggleCondensedWindow" data-active="false" title="Toggle window title format">Condense Window Title</button>
      </div>

      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Task name in tab</div>
          <div class="setting-desc">Include the current task name in the browser tab title.</div>
        </div>
        <button class="btn toggle-btn" id="toggleWindowTaskName" data-active="true" title="Toggle task name in tab">Hide Task Name in Tab</button>
      </div>

      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Countdown format</div>
          <div class="setting-desc">Shorter countdown text (e.g., 2d 3h 4m).</div>
        </div>
        <button class="btn toggle-btn" id="toggleCondensedCountdown" data-active="false" title="Toggle countdown format">Condense Countdown</button>
      </div>
    </div>

    <div class="settings-section">
      <div class="section-title">Themes</div>
      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Theme preset</div>
          <div class="setting-desc">Switch vibe instantly with animated transitions.</div>
        </div>
        <div class="dropdown" id="themePresetDropdown">
          <button class="btn dropdown-btn" id="themePresetBtn" type="button" aria-haspopup="listbox" aria-expanded="false">Default</button>
          <div class="dropdown-menu" id="themePresetMenu" role="listbox" aria-label="Theme presets">
            <button class="dropdown-item" type="button" role="option" data-value="default" aria-selected="true"><span>Default</span><span class="check">✓</span></button>
            <button class="dropdown-item" type="button" role="option" data-value="frost" aria-selected="false"><span>Frost</span><span class="check">✓</span></button>
            <button class="dropdown-item" type="button" role="option" data-value="sunset" aria-selected="false"><span>Sunset</span><span class="check">✓</span></button>
            <button class="dropdown-item" type="button" role="option" data-value="midnight" aria-selected="false"><span>Midnight</span><span class="check">✓</span></button>
          </div>
        </div>
      </div>
      <div class="theme-card">
        <div class="theme-color-grid"><div class="theme-swatch-label">Text color</div><input type="color" id="themeTextColor" value="#ffffff"></div>
        <div class="theme-color-grid"><div class="theme-swatch-label">Accent color</div><input type="color" id="themeAccentColor" value="#9ad1ff"></div>
        <div class="theme-color-grid"><div class="theme-swatch-label">Panel tint</div><input type="color" id="themePanelColor" value="#000000"></div>
      </div>
    </div>

    <div class="settings-section">
      <div class="section-title">Effects</div>

      <div class="slider-row">
        <div class="setting-meta">
          <div class="setting-name">Contrast</div>
          <div class="setting-desc">Higher = punchier text. Lower = softer look.</div>
        </div>
        <div class="slider-controls">
          <input type="range" id="contrastSlider" min="50" max="200" value="100">
          <input type="number" id="contrastInput" min="50" max="200" value="100" aria-label="Contrast value">
        </div>
      </div>

      <div class="slider-row">
        <div class="setting-meta">
          <div class="setting-name">Bloom</div>
          <div class="setting-desc">Adds glow around the countdown.</div>
        </div>
        <div class="slider-controls">
          <input type="range" id="bloomSlider" min="0" max="50" value="0">
          <input type="number" id="bloomInput" min="0" max="50" value="0" aria-label="Bloom value">
        </div>
      </div>

      <div class="slider-row">
        <div class="setting-meta">
          <div class="setting-name">Bloom opacity</div>
          <div class="setting-desc">How strong the glow looks.</div>
        </div>
        <div class="slider-controls">
          <input type="range" id="bloomOpacitySlider" min="0.1" max="1" step="0.1" value="1">
          <input type="number" id="bloomOpacityInput" min="0.1" max="1" step="0.1" value="1" aria-label="Bloom opacity value">
        </div>
      </div>


      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Bloom border</div>
          <div class="setting-desc">Clip the glow inside a frame (hard edge). Turn off for natural spill.</div>
        </div>
        <button class="btn toggle-btn" id="toggleBloomBorder" data-active="true" title="Toggle bloom border">Disable Bloom Border</button>
      </div>


      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Celebration</div>
          <div class="setting-desc">Optional confetti when you finish a task.</div>
        </div>

        <div class="dropdown" id="celebrateDropdown">
          <button class="btn dropdown-btn" id="celebrateBtn" type="button" aria-haspopup="listbox" aria-expanded="false">
            Off
          </button>

          <div class="dropdown-menu" id="celebrateMenu" role="listbox" aria-label="Celebration options">
            <button class="dropdown-item" type="button" role="option" data-value="off" aria-selected="true">
              <span>Off</span><span class="check">✓</span>
            </button>
            <button class="dropdown-item" type="button" role="option" data-value="complete" aria-selected="false">
              <span>Completed only</span><span class="check">✓</span>
            </button>
            <button class="dropdown-item" type="button" role="option" data-value="complete_skip" aria-selected="false">
              <span>Completed + skip</span><span class="check">✓</span>
            </button>
            <button class="dropdown-item" type="button" role="option" data-value="complete_skip_missed" aria-selected="false">
              <span>Completed + skip + missed</span><span class="check">✓</span>
            </button>
          </div>
        </div>
      </div>

      
      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Background</div>
          <div class="setting-desc">Choose a local image, browse Unsplash, or use the default theme background.</div>
        </div>

        <div class="dropdown" id="bgModeDropdown">
          <button class="btn dropdown-btn" id="bgModeBtn" type="button" aria-haspopup="listbox" aria-expanded="false">
            File path
          </button>

          <div class="dropdown-menu" id="bgModeMenu" role="listbox" aria-label="Background options">
            <button class="dropdown-item" type="button" role="option" data-value="default" aria-selected="false">
              <span>None (use default)</span><span class="check">✓</span>
            </button>
            <button class="dropdown-item" type="button" role="option" data-value="file" aria-selected="true">
              <span>Choose from file path</span><span class="check">✓</span>
            </button>
            <button class="dropdown-item" type="button" role="option" data-value="unsplash" aria-selected="false">
              <span>Choose from Unsplash</span><span class="check">✓</span>
            </button>
          </div>
        </div>
      </div>

      <div class="bg-panel show" id="bgFilePanel" aria-label="Background from file path">
        <div class="row">
          <input class="task-input" id="bgFilePathInput" type="text" value="./Images/Photography/Forests/2.jpg" placeholder="./Images/Photography/Forests/2.jpg">
          <button class="btn" id="bgApplyFileBtn" type="button">Use file</button>
          <button class="btn ghost" id="bgUseDefaultBtn" type="button">Use default</button>
        </div>
        <div class="note">If the file can’t be loaded (or the path is empty), you’ll automatically get the default background.</div>
      </div>

      <div class="bg-panel" id="bgUnsplashPanel" aria-label="Background from Unsplash">
        <div class="row">
          <input class="task-input" id="bgUnsplashKeyInput" type="password" placeholder="Unsplash Access Key (Client ID)">
          <button class="btn ghost" id="bgUnsplashKeyToggleBtn" type="button" title="Show/hide key" style="min-width:92px;">Show</button>
        </div>

        <div class="row">
          <input class="task-input" id="bgUnsplashQueryInput" type="text" placeholder="Search (e.g., neon city, forest, mountains)">
          <button class="btn" id="bgUnsplashSearchBtn" type="button">Get image</button>
        </div>

        <div class="row" style="justify-content:center; gap:12px; flex-wrap:wrap;">
          <label class="check"><input type="checkbox" id="bgUnsplashFeaturedOnly"> Featured only</label>

          <div class="dropdown" id="bgUnsplashRefreshDropdown" style="min-width: 260px;">
            <button class="dropdown-btn" id="bgUnsplashRefreshBtn" type="button" aria-haspopup="listbox" aria-expanded="false">Change image: On open</button>
            <div class="dropdown-menu" id="bgUnsplashRefreshMenu" role="listbox" aria-label="Unsplash refresh interval">
              <button class="dropdown-item" type="button" role="option" data-value="newtab" aria-selected="true">
                <span>On open (new tab)</span><span class="check">✓</span>
              </button>
              <button class="dropdown-item" type="button" role="option" data-value="minutes" aria-selected="false">
                <span>Every N minutes</span><span class="check">✓</span>
              </button>
              <button class="dropdown-item" type="button" role="option" data-value="hour" aria-selected="false">
                <span>Every hour</span><span class="check">✓</span>
              </button>
              <button class="dropdown-item" type="button" role="option" data-value="day" aria-selected="false">
                <span>Every day</span><span class="check">✓</span>
              </button>
              <button class="dropdown-item" type="button" role="option" data-value="week" aria-selected="false">
                <span>Every week</span><span class="check">✓</span>
              </button>
            </div>
          </div>

          <div id="bgUnsplashMinutesWrap" style="display:none; align-items:center; gap:10px;">
            <span style="opacity:.85; font-size:12px;">Minutes</span>
            <input class="task-input" id="bgUnsplashMinutesInput" type="number" min="1" max="1440" value="30" style="max-width:120px;">
          </div>
        </div>

        <div class="bg-nav">
          <button class="btn ghost" id="bgUnsplashPrevBtn" type="button">Prev</button>
          <button class="btn" id="bgUnsplashNextBtn" type="button">Next</button>
        </div>

        <div class="note">
          <b>Important:</b> Unsplash’s old <code>source.unsplash.com</code> endpoint often returns <code>503 Service Unavailable</code> now, so this uses the official Unsplash API instead.
          Add your free <b>Access Key</b> (Client ID), then press <b>Get image</b> or <b>Next</b>.
          “Featured only” uses featured <i>topics</i> (your search is ignored while it’s on).
        </div>
      </div>

<div class="slider-row">
        <div class="setting-meta">
          <div class="setting-name">Background blur</div>
          <div class="setting-desc">Blur the background behind the overlay.</div>
        </div>
        <div class="slider-controls">
          <input type="range" id="blurSlider" min="0" max="20" value="0">
          <input type="number" id="blurInput" min="0" max="20" value="0" aria-label="Background blur value">
        </div>
      </div>
    </div>

    <div class="settings-section">
      <div class="section-title">Quick presets</div>
      <div class="preset-grid">
        <button class="btn preset" id="presetCrisp" title="Sharper text, no glow">Crisp</button>
        <button class="btn preset" id="presetSoft" title="Soft glow + subtle blur">Soft</button>
        <button class="btn preset" id="presetNeon" title="Bright glow + punchy contrast">Neon</button>
      </div>
      <div class="section-note">Presets only change <b>Effects</b>.</div>
    </div>

    
    <div class="settings-section" id="tasksSection">
      <div class="section-title">Countdowns</div>
      <div class="section-note">Add multiple deadlines. The main display shows the <b>earliest unfinished</b> countdown.</div>

      <div class="task-form" role="group" aria-label="Add countdown">
        <input class="task-input" id="taskTitleInput" type="text" placeholder="Task name (optional)" maxlength="80">
        <input class="task-input" id="taskDateInput" type="datetime-local" aria-label="Due date and time">
        <button class="btn" id="addTaskBtn" title="Add countdown">Add</button>
      </div>

      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Auto-skip missed due dates</div>
          <div class="setting-desc">If a countdown reaches zero and isn’t completed, automatically move to the next one.</div>
        </div>
        <button class="btn toggle-btn" id="toggleAutoSkipMissed" data-active="true" title="Toggle auto-skip">On</button>
      </div>

      
      <div class="setting-row">
        <div class="setting-meta">
          <div class="setting-name">Catch-up mode</div>
          <div class="setting-desc">Work through missed/overdue countdowns first until you’re caught up.</div>
        </div>
        <button class="btn toggle-btn" id="toggleCatchUp" data-active="false" title="Toggle catch-up mode">Off</button>
      </div>
<div class="task-list" id="taskList" aria-label="Countdown list"></div>

      <div class="buttons">
        <button class="btn ghost" id="clearCompletedBtn" title="Remove completed countdowns">Clear Completed</button>
        <button class="btn ghost" id="clearMissedBtn" title="Remove missed/skipped countdowns">Clear Missed</button>
      </div>
      <div class="import-box" aria-label="Import and export countdowns">
        <div class="import-title">Import / Export</div>
        <div class="import-hint">Tip: Drag &amp; drop a JSON file anywhere onto the page to import.</div>
        <div class="import-note">
          Paste tasks below to import, or export your current list for backup/sharing. <span class="import-hint">Trello: export a board to JSON, or download an iCalendar (.ics) feed.</span>
          <span class="import-hint">Formats: JSON (from Export) • or line format: <span class="mono">YYYY-MM-DD HH:MM  task title</span> • or date header: <span class="mono">YYYY-MM-DD</span> then titles.</span>
        </div>

        <textarea class="task-textarea" id="importExportText" spellcheck="false"
          placeholder="Examples:
2025-12-22 00:00  📘 | Math 11-1 Notes
2025-12-22 00:00  📘 | Math 11-1

Or date header mode:
2025-12-22
📘 | Math 11-1 Notes
📘 | Math 11-1

Or paste JSON exported from this page."></textarea>

        <details class="settings-advanced"><summary>Advanced import options</summary><div class="import-options" style="margin-top:8px;">
          <label class="check"><input type="checkbox" id="replaceOnImport"> Replace existing tasks</label>
          <label class="check"><input type="checkbox" id="skipDupesOnImport" checked> Skip duplicates (same due + title)</label>
        </div></details>

        <div class="import-actions">
          <button class="btn ghost" id="exportTasksBtn" title="Export all countdowns to JSON">Export</button>
          <button class="btn ghost" id="downloadTasksBtn" title="Download a JSON backup file">Download .json</button>
          <button class="btn ghost" id="importTrelloBtn" title="Import Trello board export (.json) or Trello calendar feed (.ics)">Import Trello</button>
          <input type="file" id="trelloImportInput" accept=".json,.ics,.ical,application/json,text/calendar" style="display:none" />
          <button class="btn ghost" id="importFileBtn" title="Import from a JSON file">Import file</button>
          <button class="btn" id="importTasksBtn" title="Import countdowns from the box above">Import</button>
          <input type="file" id="importFileInput" accept=".json,application/json" style="display:none" />
        </div>
      </div>

    </div>

<div class="settings-footer" aria-label="Keyboard shortcuts">
      <span class="kbd">S</span> toggle settings • <span class="kbd">Esc</span> close
    </div>
  </div>


  
  <div class="modal" id="trelloImportModal" role="dialog" aria-modal="true" aria-labelledby="trelloImportTitle" hidden>
    <div class="modal-card">
      <div class="modal-title" id="trelloImportTitle">Trello import tab</div>
      <div class="modal-message">Choose which lists/cards to import.</div>
      <div class="import-options">
        <label class="check"><input type="checkbox" id="trelloIncludeUndated" checked> Include cards without due date (set to next hour)</label>
        <label class="check"><input type="checkbox" id="trelloIncludeArchived"> Include archived cards</label>
        <label class="check"><input type="checkbox" id="trelloIncludeCompleted"> Include completed cards</label>
      </div>
      <div class="trello-import-tab" id="trelloImportLists"></div>
      <div class="modal-actions">
        <button class="btn ghost" id="trelloImportCancelBtn" type="button">Cancel</button>
        <button class="btn" id="trelloImportApplyBtn" type="button">Import selected</button>
      </div>
    </div>
  </div>
  <button class="toggle-arrow" id="toggleArrow" aria-label="Open settings" aria-expanded="false">⚙</button>

  <script>
    // Default countdown (used only to seed your first task if none are saved yet)
    const DEFAULT_SEED_DATE = 'December 20, 2025 0:00:00 GMT-0800';

    // ===== Multi-countdown storage keys =====
    const STORAGE = {
      tasks: 'cb_tasks_v2',
      autoSkipMissed: 'cb_autoSkipMissed_v2',
      catchUpMode: 'cb_catchUpMode_v1',
      lastAction: 'cb_lastAction_v2'
    };

    // v4: celebration preference key
    const CELEBRATE_KEY = 'cb_celebrateMode_v1';


    function getOrdinalSuffix(day) {
      if (day > 3 && day < 21) return 'th';
      switch (day % 10) {
        case 1: return 'st';
        case 2: return 'nd';
        case 3: return 'rd';
        default: return 'th';
      }
    }

    function startCountdown() {
      let targetDate = new Date(DEFAULT_SEED_DATE);
      let activeTask = null;
      let tasks = [];

      const countdownWrapper = document.getElementById('countdownWrapper');
      const countdownElement = document.getElementById('countdown');
      const settingsBackdrop = document.getElementById('settingsBackdrop');
      const toastEl = document.getElementById('toast');
      let toastTimer = null;
      function showToast(message){
        if(!toastEl) return;
        toastEl.textContent = String(message || '');
        toastEl.classList.add('show');
        clearTimeout(toastTimer);
        toastTimer = setTimeout(() => toastEl.classList.remove('show'), 2200);
      }


      // Structured countdown parts
      const cdDaysUnit = document.getElementById('cdDaysUnit');
      const cdHoursUnit = document.getElementById('cdHoursUnit');
      const cdMinutesUnit = document.getElementById('cdMinutesUnit');
      const cdSecondsUnit = document.getElementById('cdSecondsUnit');

      const cdDays = document.getElementById('cdDays');
      const cdHours = document.getElementById('cdHours');
      const cdMinutes = document.getElementById('cdMinutes');
      const cdSeconds = document.getElementById('cdSeconds');

      const cdDaysLabel = document.getElementById('cdDaysLabel');
      const cdHoursLabel = document.getElementById('cdHoursLabel');
      const cdMinutesLabel = document.getElementById('cdMinutesLabel');
      const cdSecondsLabel = document.getElementById('cdSecondsLabel');

      const sepDH = document.getElementById('sepDH');
      const sepHM = document.getElementById('sepHM');
      const sepMS = document.getElementById('sepMS');

      function pad2(n){ return String(n).padStart(2,'0'); }

      const HIDE_MS = 260;

      function setUnitVisible(unitEl, visible){
        if (!unitEl) return;

        // Cancel any pending hide timeout
        if (unitEl._hideTO) { clearTimeout(unitEl._hideTO); unitEl._hideTO = null; }

        const isDisplayed = unitEl.style.display !== 'none';

        if (visible) {
          if (!isDisplayed) unitEl.style.display = 'inline-flex';
          if (prefersReducedMotion) {
            unitEl.classList.remove('is-hidden');
            return;
          }
          // Animate in
          unitEl.classList.add('is-hidden');
          void unitEl.offsetWidth; // force reflow
          unitEl.classList.remove('is-hidden');
        } else {
          if (!isDisplayed) return;
          if (prefersReducedMotion) {
            unitEl.classList.add('is-hidden');
            unitEl.style.display = 'none';
            return;
          }
          unitEl.classList.add('is-hidden');
          unitEl._hideTO = setTimeout(() => {
            unitEl.style.display = 'none';
            unitEl._hideTO = null;
          }, HIDE_MS);
        }
      }

      function setSepVisible(sepEl, visible){
        if (!sepEl) return;

        if (sepEl._hideTO) { clearTimeout(sepEl._hideTO); sepEl._hideTO = null; }

        const isDisplayed = sepEl.style.display !== 'none';

        if (visible) {
          if (!isDisplayed) sepEl.style.display = 'inline';
          if (prefersReducedMotion) {
            sepEl.classList.remove('is-hidden');
            return;
          }
          sepEl.classList.add('is-hidden');
          void sepEl.offsetWidth;
          sepEl.classList.remove('is-hidden');
        } else {
          if (!isDisplayed) return;
          if (prefersReducedMotion) {
            sepEl.classList.add('is-hidden');
            sepEl.style.display = 'none';
            return;
          }
          sepEl.classList.add('is-hidden');
          sepEl._hideTO = setTimeout(() => {
            sepEl.style.display = 'none';
            sepEl._hideTO = null;
          }, 220);
        }
      }
      function pluralize(word, n){
        return n === 1 ? word : word + 's';
      }

      let lastParts = { days: null, hours: null, minutes: null, seconds: null, condensed: null, done: null };
      let visibleNow = { days: true, hours: true, minutes: true, seconds: true };
      let secondsSwapTimeout = null;

      function animateSecondsSwap(nextText){
        if (prefersReducedMotion) { cdSeconds.textContent = nextText; return; }
        if (secondsSwapTimeout) { clearTimeout(secondsSwapTimeout); secondsSwapTimeout = null; }

        // Restart animation
        cdSeconds.classList.remove('sec-tick');
        // Force reflow to restart animation cleanly
        void cdSeconds.offsetWidth;
        cdSeconds.classList.add('sec-tick');

        // Swap text at the midpoint (when opacity is ~0)
        secondsSwapTimeout = setTimeout(() => {
          cdSeconds.textContent = nextText;
          secondsSwapTimeout = null;
        }, 170);
      }
    
      const titleElement = document.getElementById('title');

      const toggleDaysButton = document.getElementById('toggleDays');
      const toggleHoursButton = document.getElementById('toggleHours');
      const toggleMinutesButton = document.getElementById('toggleMinutes');
      const toggleSecondsButton = document.getElementById('toggleSeconds');
      const toggleTitleButton = document.getElementById('toggleTitle');
      const fontDropdown = document.getElementById('fontDropdown');
      const fontBtn = document.getElementById('fontBtn');
      const fontMenu = document.getElementById('fontMenu');
      const fontWeightDropdown = document.getElementById('fontWeightDropdown');
      const fontWeightBtn = document.getElementById('fontWeightBtn');
      const fontWeightMenu = document.getElementById('fontWeightMenu');
      const toggleUnitLabelsButton = document.getElementById('toggleUnitLabels');
      const toggleCondensedWindowButton = document.getElementById('toggleCondensedWindow');
      const toggleCondensedCountdownButton = document.getElementById('toggleCondensedCountdown');
      const toggleStatusLineButton = document.getElementById('toggleStatusLine');
      const toggleActionButtonsButton = document.getElementById('toggleActionButtons');
      const toggleWindowTaskNameButton = document.getElementById('toggleWindowTaskName');

      const contrastSlider = document.getElementById('contrastSlider');
      const contrastInput = document.getElementById('contrastInput');
      const bloomSlider = document.getElementById('bloomSlider');
      const bloomInput = document.getElementById('bloomInput');
      const bloomOpacitySlider = document.getElementById('bloomOpacitySlider');
      const bloomOpacityInput = document.getElementById('bloomOpacityInput');
      const blurSlider = document.getElementById('blurSlider');
      const blurInput = document.getElementById('blurInput');
      const resetSettingsButton = document.getElementById('resetSettings');
      const saveStartupSettingsButton = document.getElementById('saveStartupSettings');
      const presetCrispButton = document.getElementById('presetCrisp');
      const presetSoftButton = document.getElementById('presetSoft');
      const presetNeonButton = document.getElementById('presetNeon');

      const bloomClipper = document.getElementById('bloomClipper');
      const toggleBloomBorderButton = document.getElementById('toggleBloomBorder');
      
      const controlPanel = document.getElementById('controlPanel');
      const toggleArrow = document.getElementById('toggleArrow');

      let showDays = true;
      let showHours = true;
      let showMinutes = true;
      let showSeconds = true;


      // Font options
      const FONT_OPTIONS = {
        inter: "'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif",
        system: "system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif",
        poppins: "'Poppins', system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif",
        montserrat: "'Montserrat', system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif",
        space: "'Space Grotesk', system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif",
        mono: "'JetBrains Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
        serif: "'Playfair Display', ui-serif, Georgia, 'Times New Roman', Times, serif",
      };

      const FONT_LABELS = {
        inter: 'Inter',
        system: 'System UI',
        poppins: 'Poppins',
        montserrat: 'Montserrat',
        space: 'Space Grotesk',
        mono: 'JetBrains Mono',
        serif: 'Playfair Display'
      };
      const FONT_WEIGHT_LABELS = { '200':'Light', '400':'Normal', '600':'Semibold', '700':'Bold' };
      let selectedFont = (localStorage.getItem('cb_font') || 'inter');
      if (!FONT_OPTIONS[selectedFont]) selectedFont = 'inter';
      document.documentElement.style.setProperty('--font-main', FONT_OPTIONS[selectedFont]);

      function closeDropdown(dropdownEl, btnEl){ if(!dropdownEl) return; dropdownEl.classList.remove('open'); btnEl?.setAttribute('aria-expanded','false'); }
      function openDropdown(dropdownEl, btnEl){ if(!dropdownEl) return; dropdownEl.classList.add('open'); btnEl?.setAttribute('aria-expanded','true'); }
      function syncOptionDropdown(menuEl, btnEl, value, labels){
        menuEl?.querySelectorAll('.dropdown-item[data-value]').forEach((item)=>{
          const on = item.getAttribute('data-value') === value;
          item.setAttribute('aria-selected', on ? 'true' : 'false');
        });
        if(btnEl) btnEl.textContent = labels[value] || value;
      }
      syncOptionDropdown(fontMenu, fontBtn, selectedFont, FONT_LABELS);
      syncOptionDropdown(fontWeightMenu, fontWeightBtn, '400', FONT_WEIGHT_LABELS);

      // Bloom border (clipped glow) toggle
      let bloomBorderOn = (localStorage.getItem('cb_bloomBorder') || 'on') !== 'off';
      function applyBloomBorderState(){
        if (!bloomClipper) return;
        bloomClipper.classList.toggle('unclipped', !bloomBorderOn);
        bloomClipper.dataset.clipped = String(!!bloomBorderOn);
        if (toggleBloomBorderButton){
          toggleBloomBorderButton.dataset.active = String(!!bloomBorderOn);
          toggleBloomBorderButton.textContent = bloomBorderOn ? 'Disable Bloom Border' : 'Enable Bloom Border';
        }
        localStorage.setItem('cb_bloomBorder', bloomBorderOn ? 'on' : 'off');
      }
      applyBloomBorderState();

      // If a unit is toggled on while its value is 0, we can "force show 0" for that unit
      const forceShowZero = { days: false, hours: false, minutes: false, seconds: false };

      // Unit label toggle (labels vs colons)
      let showUnitLabels = true;

      let useCondensedWindowFormat = false;
      let useCondensedCountdownFormat = false;

      // Extra visibility + window title options
      let showStatusLine = true;
      let showTaskActions = true;
      let includeTaskNameInWindowTitle = true;
      let currentPresetId = null;
      const statusVisibility = { task:true, due:true, pending:true, completed:true, missed:true, trello:true };

      function setToggleButtonText(button, isOn, label){
        if(!button) return;
        button.dataset.active = String(!!isOn);
        button.textContent = (isOn ? 'Hide ' : 'Show ') + label;
      }

      function setActivePreset(presetId){
        currentPresetId = presetId || null;
        presetCrispButton?.classList.toggle('is-active', currentPresetId === 'crisp');
        presetSoftButton?.classList.toggle('is-active', currentPresetId === 'soft');
        presetNeonButton?.classList.toggle('is-active', currentPresetId === 'neon');
      }

      function applyExtraVisibility(){
        statusLine?.classList.toggle('collapsed', !showStatusLine);
        taskActions?.classList.toggle('collapsed', !showTaskActions);
      }

      function syncExtraToggleButtons(){
        setToggleButtonText(toggleStatusLineButton, showStatusLine, 'Status Line');
        setToggleButtonText(toggleActionButtonsButton, showTaskActions, 'Action Buttons');
        setToggleButtonText(toggleWindowTaskNameButton, includeTaskNameInWindowTitle, 'Task Name in Tab');
      }
      // ===== Multi-countdown (tasks) =====
      const statusLine = document.getElementById('statusLine');
      const taskActions = document.getElementById('taskActions');
      const completeTaskBtn = document.getElementById('completeTaskBtn');
      const skipTaskBtn = document.getElementById('skipTaskBtn');
      const undoLastBtn = document.getElementById('undoLastBtn');
      const catchUpBtn = document.getElementById('catchUpBtn');

      const taskTitleInput = document.getElementById('taskTitleInput');
      const taskDateInput = document.getElementById('taskDateInput');
      const addTaskBtn = document.getElementById('addTaskBtn');
      const taskListEl = document.getElementById('taskList');
      const clearCompletedBtn = document.getElementById('clearCompletedBtn');
      const clearMissedBtn = document.getElementById('clearMissedBtn');

      // Import / Export
      const importExportText = document.getElementById('importExportText');
      const replaceOnImport = document.getElementById('replaceOnImport');
      const skipDupesOnImport = document.getElementById('skipDupesOnImport');
      const exportTasksBtn = document.getElementById('exportTasksBtn');
      const downloadTasksBtn = document.getElementById('downloadTasksBtn');
      const importFileBtn = document.getElementById('importFileBtn');
      const importFileInput = document.getElementById('importFileInput');
      const importTasksBtn = document.getElementById('importTasksBtn');
      const importTrelloBtn = document.getElementById('importTrelloBtn');
      const trelloImportInput = document.getElementById('trelloImportInput');
      const topError = document.getElementById('topError');
      const statShowTask = document.getElementById('statShowTask');
      const statShowDue = document.getElementById('statShowDue');
      const statShowPending = document.getElementById('statShowPending');
      const statShowCompleted = document.getElementById('statShowCompleted');
      const statShowMissed = document.getElementById('statShowMissed');
      const statShowTrello = document.getElementById('statShowTrello');
      const themePresetDropdown = document.getElementById('themePresetDropdown');
      const themePresetBtn = document.getElementById('themePresetBtn');
      const themePresetMenu = document.getElementById('themePresetMenu');
      const themeTextColor = document.getElementById('themeTextColor');
      const themeAccentColor = document.getElementById('themeAccentColor');
      const themePanelColor = document.getElementById('themePanelColor');
      const trelloImportModal = document.getElementById('trelloImportModal');
      const trelloImportLists = document.getElementById('trelloImportLists');
      const trelloImportApplyBtn = document.getElementById('trelloImportApplyBtn');
      const trelloImportCancelBtn = document.getElementById('trelloImportCancelBtn');
      const trelloIncludeUndated = document.getElementById('trelloIncludeUndated');
      const trelloIncludeArchived = document.getElementById('trelloIncludeArchived');
      const trelloIncludeCompleted = document.getElementById('trelloIncludeCompleted');

      const toggleAutoSkipMissedBtn = document.getElementById('toggleAutoSkipMissed');
      const toggleCatchUpBtn = document.getElementById('toggleCatchUp');

      // Date helpers
      const monthNames = ["January","February","March","April","May","June","July","August","September","October","November","December"];
      function getTzAbbrev(d){
        try{
          const parts = new Intl.DateTimeFormat(undefined, { timeZoneName: 'short' }).formatToParts(d);
          const tz = parts.find(p => p.type === 'timeZoneName')?.value;
          return tz || '';
        }catch(e){ return ''; }
      }
      function formatDueLong(d){
        const dayNum = d.getDate();
        const month = monthNames[d.getMonth()];
        const year = d.getFullYear();
        const hours12 = d.getHours() % 12 || 12;
        const minutes2 = String(d.getMinutes()).padStart(2, '0');
        const ampm = d.getHours() >= 12 ? 'PM' : 'AM';
        const tz = getTzAbbrev(d);
        return `${month} ${dayNum}${getOrdinalSuffix(dayNum)}, ${year} ${hours12}:${minutes2} ${ampm}${tz ? ' ' + tz : ''}`;
      }
      function escapeHtml(s){
        return String(s ?? '')
          .replaceAll('&','&amp;')
          .replaceAll('<','&lt;')
          .replaceAll('>','&gt;')
          .replaceAll('"','&quot;')
          .replaceAll("'","&#39;");
      }
      function safeUrl(u){
        const s = String(u || '').trim();
        if(!s) return null;
        try{
          const url = new URL(s, window.location.href);
          if(url.protocol !== 'http:' && url.protocol !== 'https:') return null;
          return url.toString();
        }catch(e){
          return null;
        }
      }



      // Load + seed
      function loadTasks(){
        try{
          const raw = localStorage.getItem(STORAGE.tasks);
          const parsed = raw ? JSON.parse(raw) : [];
          return Array.isArray(parsed) ? parsed : [];
        }catch(e){ return []; }
      }
      function reindexTieOrders(list){
        const arr = Array.isArray(list) ? list : [];
        const groups = new Map();
        for(const t of arr){
          if(!t) continue;
          const due = Number(t.dueTs);
          if(!Number.isFinite(due)) continue;
          if(!groups.has(due)) groups.set(due, []);
          groups.get(due).push(t);
        }
        for(const [due, group] of groups){
          group.sort((a,b) => {
            const ao = Number.isFinite(a && a.tieOrder) ? Number(a.tieOrder) : NaN;
            const bo = Number.isFinite(b && b.tieOrder) ? Number(b.tieOrder) : NaN;
            if(Number.isFinite(ao) && Number.isFinite(bo) && ao !== bo) return ao - bo;
            if(Number.isFinite(ao) && !Number.isFinite(bo)) return -1;
            if(!Number.isFinite(ao) && Number.isFinite(bo)) return 1;
const ac = Number.isFinite(a && a.createdAt) ? Number(a.createdAt) : 0;
            const bc = Number.isFinite(b && b.createdAt) ? Number(b.createdAt) : 0;
            if(ac !== bc) return ac - bc;

            return String((a && a.id) || '').localeCompare(String((b && b.id) || ''));
          });
          group.forEach((t,i) => { t.tieOrder = i; });
        }
      }

      function saveTasks(next){
        // If called with no args, save the current in-memory tasks.
        const toSave = (next === undefined) ? tasks : next;
        tasks = Array.isArray(toSave) ? toSave : [];
        try{ reindexTieOrders(tasks); }catch(_){}
        localStorage.setItem(STORAGE.tasks, JSON.stringify(tasks));
      }

      // Start empty (no auto-seed). Add/import tasks in Settings.
      tasks = loadTasks();
      try{ saveTasks(tasks); }catch(_){ }
// Auto-skip missed
      let autoSkipMissed = (localStorage.getItem(STORAGE.autoSkipMissed) || 'true') === 'true';
      function syncAutoSkipButton(){
        if (!toggleAutoSkipMissedBtn) return;
        toggleAutoSkipMissedBtn.dataset.active = String(autoSkipMissed);
        toggleAutoSkipMissedBtn.textContent = autoSkipMissed ? 'On' : 'Off';
      }
      syncAutoSkipButton();
      toggleAutoSkipMissedBtn?.addEventListener('click', () => {
        autoSkipMissed = !autoSkipMissed;
        localStorage.setItem(STORAGE.autoSkipMissed, String(autoSkipMissed));
        syncAutoSkipButton();
      });


      // Catch-up mode (focus on missed/overdue tasks)
      let catchUpMode = (localStorage.getItem(STORAGE.catchUpMode) || 'false') === 'true';

      function syncCatchUpButtons(){
        if (toggleCatchUpBtn){
          toggleCatchUpBtn.dataset.active = String(catchUpMode);
          toggleCatchUpBtn.textContent = catchUpMode ? 'On' : 'Off';
        }
        // Main button visibility/text is handled in updateMainButtons(), but keep a safe default here.
        if (catchUpBtn){
          catchUpBtn.textContent = catchUpMode ? 'Exit catch-up' : 'Catch-up';
        }
      }

      function setCatchUpMode(next){
        catchUpMode = !!next;
        try{ localStorage.setItem(STORAGE.catchUpMode, String(catchUpMode)); }catch(e){}
        syncCatchUpButtons();
        setActiveFromList();
      }

      syncCatchUpButtons();
      toggleCatchUpBtn?.addEventListener('click', () => setCatchUpMode(!catchUpMode));
      catchUpBtn?.addEventListener('click', () => setCatchUpMode(!catchUpMode));

      function sortByDue(a,b){
        const ad = Number((a && a.dueTs) || 0);
        const bd = Number((b && b.dueTs) || 0);
        if (ad !== bd) return ad - bd;

        // v9: allow manual ordering when due date/time is identical
        const ao = Number.isFinite(a && a.tieOrder) ? Number(a.tieOrder) : NaN;
        const bo = Number.isFinite(b && b.tieOrder) ? Number(b.tieOrder) : NaN;

        if (Number.isFinite(ao) && Number.isFinite(bo) && ao !== bo) return ao - bo;
        if (Number.isFinite(ao) && !Number.isFinite(bo)) return -1;
        if (!Number.isFinite(ao) && Number.isFinite(bo)) return 1;

        const ac = Number.isFinite(a && a.createdAt) ? Number(a.createdAt) : 0;
        const bc = Number.isFinite(b && b.createdAt) ? Number(b.createdAt) : 0;
        if (ac !== bc) return ac - bc;

        return String((a && a.id) || '').localeCompare(String((b && b.id) || ''));
      }

      function getCatchUpTask(){
        const now = Date.now();
        const missed = tasks
          .filter(t => !t?.completed && Number.isFinite(t?.dueTs) && (
            (t?.archived && t?.archivedReason === 'missed') ||
            (!t?.archived && t?.dueTs < now)
          ))
          .sort(sortByDue);
        return missed[0] || null;
      }

      function getActiveTask(){
        if (catchUpMode) {
          const cu = getCatchUpTask();
          if (cu) return cu;
          // Nothing to catch up on — return to normal mode automatically
          catchUpMode = false;
          try{ localStorage.setItem(STORAGE.catchUpMode, 'false'); }catch(e){}
          // sync UI if available
          if (typeof syncCatchUpButtons === 'function') syncCatchUpButtons();
          showToast('All caught up — back to normal');
        }

        const pending = tasks
          .filter(t => !t?.completed && !t?.archived && Number.isFinite(t?.dueTs))
          .sort(sortByDue);
        return pending[0] || null;
      }

function setLastAction(obj){
        try{ localStorage.setItem(STORAGE.lastAction, JSON.stringify(obj)); }catch(e){}
      }
      function getLastAction(){
        try{
          const raw = localStorage.getItem(STORAGE.lastAction);
          return raw ? JSON.parse(raw) : null;
        }catch(e){ return null; }
      }

      function updateTitleAndStatus(){
        if (!titleElement) return;

        // No tasks left
        if (!activeTask || !Number.isFinite(activeTask?.dueTs)) {
          titleElement.textContent = 'No countdowns — add one in Settings';
          statusLine && (statusLine.innerHTML = `<span class="pill">Open settings (⚙) and add a countdown</span>`);
          document.title = 'Countdown';
          return;
        }

        const due = new Date(activeTask.dueTs);
        const name = (activeTask.title || 'Countdown').trim();
        titleElement.textContent = `${name} — due ${formatDueLong(due)}`;

        const pending = tasks.filter(t => !t.completed && !t.archived).length;
        const completed = tasks.filter(t => !!t.completed).length;
        const missed = tasks.filter(t => !!t.archived && !t.completed).length;

        const pills = [];
                if (catchUpMode) pills.push(`<span class=\"pill\">Catch-up mode</span>`);
pills.push(`<span class="pill">Showing: <b>${escapeHtml(name)}</b></span>`);
        pills.push(`<span class="pill">Due: ${escapeHtml(formatDueLong(due))}</span>`);
        const link = safeUrl(activeTask.url || activeTask.link || activeTask.shortUrl);
        if(link) pills.push(`<a class="pill pill-link" href="${escapeHtml(link)}" target="_blank" rel="noopener">Open in Trello ↗</a>`);
        pills.push(`<span class="pill">Pending: ${pending}</span>`);
        if (completed) pills.push(`<span class="pill">Completed: ${completed}</span>`);
        if (missed) pills.push(`<span class="pill">Missed/Skipped: ${missed}</span>`);
        statusLine && (statusLine.innerHTML = pills.join(''));
      }

      function updateMainButtons(){
        const hasActive = !!activeTask;
        if (completeTaskBtn) completeTaskBtn.disabled = !hasActive;
        if (skipTaskBtn) skipTaskBtn.disabled = !hasActive;
        if (undoLastBtn) {
          const la = getLastAction();
          undoLastBtn.disabled = !la;
        }
      }

      function setActiveFromList(){
        const next = getActiveTask();
        const changed = (!activeTask && next) || (activeTask && (!next || activeTask.id !== next.id));
        activeTask = next;
        targetDate = activeTask ? new Date(activeTask.dueTs) : null;
        if (changed) {
          // Rebuild title + status immediately
          updateTitleAndStatus();
        }
        renderTaskList();
        updateMainButtons();
      }

      function addTask(){
        const dueRaw = (taskDateInput?.value || '').trim();
        if (!dueRaw) {
          statusLine && (statusLine.innerHTML = `<span class="pill">Pick a due date/time first</span>`);
          return;
        }
        const due = new Date(dueRaw);
        const dueTs = due.getTime();
        if (!Number.isFinite(dueTs)) {
          statusLine && (statusLine.innerHTML = `<span class="pill">That date/time didn’t parse — try again</span>`);
          return;
        }
        const title = (taskTitleInput?.value || '').trim() || 'Countdown';
        const id = 't_' + String(Date.now()) + '_' + String(Math.floor(Math.random()*1e6));
        tasks.push({
          id, title,
          dueTs,
          createdAt: Date.now(),
          completed: false,
          completedAt: null,
          archived: false,
          archivedAt: null,
          archivedReason: null
        });
        tasks.sort(sortByDue);
        saveTasks(tasks);
        if (taskTitleInput) taskTitleInput.value = '';
        if (taskDateInput) taskDateInput.value = '';
        setActiveFromList();
      }

      addTaskBtn?.addEventListener('click', addTask);
      taskDateInput?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') addTask();
      });
      taskTitleInput?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') addTask();
      });

      function markCompleted(id){
        const i = tasks.findIndex(t => t.id === id);
        if (i < 0) return;
        tasks[i].completed = true;
        tasks[i].completedAt = Date.now();
        tasks[i].archived = false;
        tasks[i].archivedAt = null;
        tasks[i].archivedReason = null;
        saveTasks(tasks);
        setLastAction({ type: 'complete', id, at: Date.now() });
        setActiveFromList();
      }

      function archiveTask(id, reason){
        const i = tasks.findIndex(t => t.id === id);
        if (i < 0) return;
        tasks[i].archived = true;
        tasks[i].archivedAt = Date.now();
        tasks[i].archivedReason = reason || 'archived';
        saveTasks(tasks);
        setLastAction({ type: 'archive', id, at: Date.now(), reason: tasks[i].archivedReason });
        setActiveFromList();
      }

      function restoreTask(id){
        const i = tasks.findIndex(t => t.id === id);
        if (i < 0) return;
        tasks[i].completed = false;
        tasks[i].completedAt = null;
        tasks[i].archived = false;
        tasks[i].archivedAt = null;
        tasks[i].archivedReason = null;
        saveTasks(tasks);
        setLastAction({ type: 'restore', id, at: Date.now() });
        setActiveFromList();
      }

      function deleteTask(id){
        tasks = tasks.filter(t => t.id !== id);
        saveTasks(tasks);
        setLastAction({ type: 'delete', id, at: Date.now() });
        setActiveFromList();
      }

      function clearCompleted(){
        tasks = tasks.filter(t => !t.completed);
        saveTasks(tasks);
        setLastAction({ type: 'clearCompleted', at: Date.now() });
        setActiveFromList();
      }
      function clearMissed(){
        tasks = tasks.filter(t => !(t.archived && !t.completed));
        saveTasks(tasks);
        setLastAction({ type: 'clearMissed', at: Date.now() });
        setActiveFromList();
      }

      clearCompletedBtn?.addEventListener('click', clearCompleted);
      clearMissedBtn?.addEventListener('click', clearMissed);

      // ===== Import / Export (tasks) =====
      function getTasksExportPayload(){
        try{
          return JSON.stringify({ version: 1, exportedAt: new Date().toISOString(), tasks: tasks }, null, 2);
        } catch(e){
          // Fallback to a shallow export if something odd is in memory
          const safe = (tasks || []).map(t => ({
            id: t?.id, title: t?.title, dueTs: t?.dueTs, createdAt: t?.createdAt,
            completed: !!t?.completed, completedAt: t?.completedAt ?? null,
            archived: !!t?.archived, archivedAt: t?.archivedAt ?? null, archivedReason: t?.archivedReason ?? null
          }));
          return JSON.stringify({ version: 1, exportedAt: new Date().toISOString(), tasks: safe }, null, 2);
        }
      }

      async function copyToClipboard(text){
        try{
          await navigator.clipboard.writeText(String(text));
          return true;
        } catch(e){
          return false;
        }
      }

      async function exportTasks(){
        const payload = getTasksExportPayload();
        if(importExportText){
          importExportText.value = payload;
          importExportText.focus();
          importExportText.select();
        }
        const ok = await copyToClipboard(payload);
        showToast(ok ? 'Export copied to clipboard.' : 'Export ready in the box.');
      }

      function downloadTasks(){
        const payload = getTasksExportPayload();
        const blob = new Blob([payload], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        const stamp = new Date().toISOString().replace(/[:.]/g,'-');
        a.download = 'countdowns-' + stamp + '.json';
        document.body.appendChild(a);
        a.click();
        setTimeout(() => { try{ URL.revokeObjectURL(a.href); }catch(e){} a.remove(); }, 0);
        showToast('Downloaded JSON backup.');
      }

      function normalizeImportedTask(raw, createdAtFallback){
        const obj = raw || {};
        const title = String(obj.title ?? obj.name ?? obj.task ?? '').trim();
        let dueTs = Number(obj.dueTs);

        if(!Number.isFinite(dueTs)){
          const dueStr = obj.due ?? obj.dueDate ?? obj.date ?? obj.datetime;
          if(dueStr){
            const d = new Date(dueStr);
            const ts = d.getTime();
            if(Number.isFinite(ts)) dueTs = ts;
          }
        }

        const createdAt = Number.isFinite(obj.createdAt) ? Number(obj.createdAt) : (Number(createdAtFallback) || Date.now());
        const completed = !!obj.completed;
        const completedAt = Number.isFinite(obj.completedAt) ? Number(obj.completedAt) : (completed ? Date.now() : null);
        const archived = !!obj.archived;
        const archivedAt = Number.isFinite(obj.archivedAt) ? Number(obj.archivedAt) : (archived ? Date.now() : null);
        const archivedReason = (obj.archivedReason !== undefined && obj.archivedReason !== null) ? String(obj.archivedReason) : null;

        if(!Number.isFinite(dueTs)) return null;

        return {
          id: String(obj.id || ('t_' + createdAt + '_' + Math.random().toString(36).slice(2,7))),
          title,
          dueTs,
          createdAt,
          completed,
          completedAt,
          archived,
          archivedAt,
          archivedReason
        };
      }

      function parseImportTextToTasks(text){
        const raw = String(text || '').trim();
        const errors = [];
        const out = [];

        if(!raw) return { tasks: out, errors };

        // JSON (exported from this page)
        if(raw.startsWith('{') || raw.startsWith('[')){
          try{
            const parsed = JSON.parse(raw);
            const list = Array.isArray(parsed) ? parsed : (Array.isArray(parsed?.tasks) ? parsed.tasks : []);
            const base = Date.now();
            list.forEach((item, idx) => {
              const t = normalizeImportedTask(item, base + idx);
              if(t) out.push(t);
            });
            if(!list.length) errors.push('No tasks found in that JSON.');
            return { tasks: out, errors };
          } catch(e){
            errors.push('Could not parse JSON. Try the line format shown in the placeholder.');
            return { tasks: out, errors };
          }
        }

        // Line format
        const lines = raw.split(/\r?\n/);
        let currentDate = null;
        const base = Date.now();
        let counter = 0;

        for(const line of lines){
          let s = String(line || '').trim();
          if(!s) continue;
          if(s.startsWith('#') || s.startsWith('//')) continue;

          // Date header mode: "YYYY-MM-DD"
          if(/^\d{4}-\d{2}-\d{2}$/.test(s)){
            currentDate = s;
            continue;
          }

          let dateStr = null;
          let timeStr = '00:00';
          let titleStr = null;

          // "YYYY-MM-DD HH:MM  Title" or "YYYY-MM-DDTHH:MM Title"
          const m = s.match(/^(\d{4}-\d{2}-\d{2})(?:[ T](\d{2}:\d{2})(?::\d{2})?)?\s+(.+)$/);
          if(m){
            dateStr = m[1];
            if(m[2]) timeStr = String(m[2]).slice(0,5);
            titleStr = m[3];
          } else if(currentDate){
            dateStr = currentDate;
            titleStr = s;
          } else {
            errors.push('Could not parse line: ' + s);
            continue;
          }

          titleStr = String(titleStr || '').replace(/^[-•]\s+/, '').trim();
          const dt = new Date(String(dateStr) + 'T' + String(timeStr));
          const dueTs = dt.getTime();
          if(!Number.isFinite(dueTs)){
            errors.push('Bad date/time: ' + dateStr + ' ' + timeStr);
            continue;
          }

          const createdAt = base + counter;
          counter += 1;

          out.push({
            id: 't_' + createdAt + '_' + Math.random().toString(36).slice(2,7),
            title: titleStr,
            dueTs,
            createdAt,
            completed: false,
            completedAt: null,
            archived: false,
            archivedAt: null,
            archivedReason: null
          });
        }

        return { tasks: out, errors };
      }

      
      function importTasks(){
        const text = importExportText?.value || '';
        const replace = !!replaceOnImport?.checked;
        const skipDupes = (skipDupesOnImport?.checked ?? true);

        const parsed = parseImportTextToTasks(text);
        const incoming = parsed.tasks || [];

        if(parsed.errors && parsed.errors.length){
          // Keep it light: show the first error as a toast
          showToast(parsed.errors[0]);
        }
        if(!incoming.length){
          showToast('Nothing to import.');
          return;
        }

        if(replace){
          const ok = confirm('Replace your existing countdowns with the imported list?');
          if(!ok) return;
          tasks = [];
          try{ localStorage.removeItem(STORAGE.lastAction); }catch(e){}
        }

        const existingKey = new Set();
        if(skipDupes){
          for(const t of tasks){
            const k = String(Number(t?.dueTs) || 0) + '::' + String(t?.title || '').trim();
            existingKey.add(k);
          }
        }

        let added = 0;
        let skipped = 0;
        const addedIds = [];

        for(const t of incoming){
          const title = String(t.title || '').trim();
          const key = String(Number(t?.dueTs) || 0) + '::' + title;

          if(skipDupes && existingKey.has(key)){
            skipped += 1;
            continue;
          }
          if(skipDupes) existingKey.add(key);

          const id = String(t.id || ('t_' + (t.createdAt || Date.now()) + '_' + Math.random().toString(36).slice(2,7)));

          tasks.push({
            id,
            title,
            dueTs: Number(t.dueTs),
            createdAt: Number.isFinite(t.createdAt) ? Number(t.createdAt) : Date.now(),
            completed: !!t.completed,
            completedAt: (t.completedAt !== undefined ? t.completedAt : null),
            archived: !!t.archived,
            archivedAt: (t.archivedAt !== undefined ? t.archivedAt : null),
            archivedReason: (t.archivedReason !== undefined ? t.archivedReason : null)
          });

          added += 1;
          addedIds.push(id);
        }

        tasks.sort(sortByDue);
        saveTasks(tasks);

        // Refresh the active countdown + UI immediately
        setActiveFromList();
        updateTitleAndStatus();
        updateCountdown();
        updateMainButtons();

        // Smooth import animations
        if(!prefersReducedMotion){
          try{
            countdownWrapper?.classList.remove('import-flash');
            void countdownWrapper?.offsetWidth;
            countdownWrapper?.classList.add('import-flash');
            setTimeout(() => countdownWrapper?.classList.remove('import-flash'), 720);
          }catch(_){}
        }

        try{
          if(taskListEl && addedIds.length){
            const esc = (s) => (window.CSS && CSS.escape) ? CSS.escape(String(s)) : String(s).replace(/"/g,'\\\"');
            // Animate newly-added rows
            for(const id of addedIds.slice(0, 200)){
              const el = taskListEl.querySelector('.task-row[data-id="' + esc(id) + '"]');
              if(el){
                el.classList.remove('just-added');
                void el.offsetWidth;
                el.classList.add('just-added');
                setTimeout(() => el.classList.remove('just-added'), 650);
              }
            }
            // Highlight and scroll to the currently active item
            const activeRow = taskListEl.querySelector('.task-row.is-active');
            if(activeRow){
              activeRow.classList.add('import-highlight');
              activeRow.scrollIntoView({ block: 'center', behavior: prefersReducedMotion ? 'auto' : 'smooth' });
              setTimeout(() => activeRow.classList.remove('import-highlight'), 1500);
            }
          }
        }catch(_){}

        showToast('Imported ' + added + (skipped ? (' • skipped ' + skipped + ' duplicate' + (skipped===1?'':'s')) : '') + '.');
      }


      exportTasksBtn?.addEventListener('click', exportTasks);
      downloadTasksBtn?.addEventListener('click', downloadTasks);
      importTasksBtn?.addEventListener('click', importTasks);

      importFileBtn?.addEventListener('click', () => importFileInput?.click());
      importFileInput?.addEventListener('change', async (e) => {
        const file = e?.target?.files?.[0];
        if(!file) return;
        try{
          const text = await file.text();
          if(importExportText) importExportText.value = text;
          importTasks();
        } catch(err){
          showTopError('Could not read that file.');
        } finally {
          try{ e.target.value = ''; }catch(_){}
        }
      });
      // ===== Trello import (.json board export or .ics iCalendar feed) =====
      function mergeIncomingTasks(incoming, sourceLabel){
        const replace = !!replaceOnImport?.checked;
        const skipDupes = (skipDupesOnImport?.checked ?? true);

        const parsed = Array.isArray(incoming) ? incoming : [];
        if(!parsed.length){
          showToast('Nothing to import.');
          return;
        }

        if(replace){
          const ok = confirm('Replace your existing countdowns with the imported ' + (sourceLabel || 'tasks') + '?\n\nThis will clear your current countdown list.');
          if(!ok) return;
          tasks = [];
          try{ localStorage.removeItem(STORAGE.lastAction); }catch(e){}
        }

        const existingKey = new Set();
        if(skipDupes){
          for(const t of tasks){
            const k = String(Number(t?.dueTs) || 0) + '::' + String(t?.title || '').trim();
            existingKey.add(k);
          }
        }

        const base = Date.now();
        let added = 0;
        let skipped = 0;
        const addedIds = [];

        for(let i=0;i<parsed.length;i++){
          const it = parsed[i];
          if(!it || !Number.isFinite(Number(it.dueTs))) continue;
          const title = String(it.title || '').trim();
          const dueTs = Number(it.dueTs);
          if(!Number.isFinite(dueTs)) continue;

          const key = String(dueTs) + '::' + title;
          if(skipDupes && existingKey.has(key)){ skipped += 1; continue; }
          if(skipDupes) existingKey.add(key);

          const createdAt = Number.isFinite(Number(it.createdAt)) ? Number(it.createdAt) : (base + i);
          const id = String(it.id || ('t_' + createdAt + '_' + Math.random().toString(36).slice(2,7)));

          tasks.push({
            id,
            title,
            dueTs,
            createdAt,
            completed: !!it.completed,
            completedAt: (it.completedAt !== undefined ? it.completedAt : (it.completed ? Date.now() : null)),
            archived: !!it.archived,
            archivedAt: (it.archivedAt !== undefined ? it.archivedAt : (it.archived ? Date.now() : null)),
            archivedReason: (it.archivedReason !== undefined ? it.archivedReason : null),

            // Optional link (e.g., Trello card URL)
            url: it.url || it.link || it.shortUrl || null
          });

          added += 1;
          addedIds.push(id);
        }

        tasks.sort(sortByDue);
        saveTasks(tasks);

        setActiveFromList();
        updateTitleAndStatus();
        updateCountdown();
        updateMainButtons();

        // Import animations (reuse the same vibe as normal import)
        const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        if(!prefersReduced){
          try{
            countdownWrapper?.classList.remove('import-flash');
            void countdownWrapper?.offsetWidth;
            countdownWrapper?.classList.add('import-flash');
            setTimeout(() => countdownWrapper?.classList.remove('import-flash'), 720);
          }catch(_){}
        }

        try{
          if(taskListEl && addedIds.length){
            const esc = (s) => (window.CSS && CSS.escape) ? CSS.escape(String(s)) : String(s).replace(/"/g,'\\"');
            for(const id of addedIds.slice(0, 200)){
              const el = taskListEl.querySelector('.task-row[data-id="' + esc(id) + '"]');
              if(el){
                el.classList.remove('just-added');
                void el.offsetWidth;
                el.classList.add('just-added');
                setTimeout(() => el.classList.remove('just-added'), 650);
              }
            }
            const activeRow = taskListEl.querySelector('.task-row.is-active');
            if(activeRow){
              activeRow.classList.add('import-highlight');
              activeRow.scrollIntoView({ block: 'center', behavior: prefersReduced ? 'auto' : 'smooth' });
              setTimeout(() => activeRow.classList.remove('import-highlight'), 1500);
            }
          }
        }catch(_){}

        showToast('Imported ' + added + (skipped ? (' • skipped ' + skipped + ' duplicate' + (skipped===1?'':'s')) : '') + '.');
      }

      function unfoldIcs(text){
        // RFC5545 line folding: lines may continue with a leading space/tab.
        return String(text || '').replace(/\r?\n[ \t]/g, '');
      }

      function parseIcsDate(val){
        const s = String(val || '').trim();
        if(!s) return null;

        // DATE (all-day): YYYYMMDD
        if(/^\d{8}$/.test(s)){
          const y = s.slice(0,4), m = s.slice(4,6), d = s.slice(6,8);
          const dt = new Date(`${y}-${m}-${d}T00:00:00`);
          const ts = dt.getTime();
          return Number.isFinite(ts) ? ts : null;
        }

        // DATE-TIME: YYYYMMDDTHHMMSS(Z)
        const m = s.match(/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})(Z)?$/);
        if(m){
          const iso = `${m[1]}-${m[2]}-${m[3]}T${m[4]}:${m[5]}:${m[6]}${m[7] ? 'Z' : ''}`;
          const dt = new Date(iso);
          const ts = dt.getTime();
          return Number.isFinite(ts) ? ts : null;
        }

        // DATE-TIME without seconds: YYYYMMDDTHHMM(Z)
        const m2 = s.match(/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(Z)?$/);
        if(m2){
          const iso = `${m2[1]}-${m2[2]}-${m2[3]}T${m2[4]}:${m2[5]}:00${m2[6] ? 'Z' : ''}`;
          const dt = new Date(iso);
          const ts = dt.getTime();
          return Number.isFinite(ts) ? ts : null;
        }

        // Fallback: let Date try
        const dt = new Date(s);
        const ts = dt.getTime();
        return Number.isFinite(ts) ? ts : null;
      }

      function parseIcsTextToTasks(text){
        const unfolded = unfoldIcs(text);
        if(!/BEGIN:VCALENDAR/i.test(unfolded)) return [];

        const parts = unfolded.split(/BEGIN:VEVENT/i).slice(1);
        const out = [];
        const base = Date.now();
let idx = 0;

        for(const p of parts){
          const block = p.split(/END:VEVENT/i)[0] || '';
          const lines = block.split(/\r?\n/);
          let summary = '';
          let dueVal = null;
          let url = null;

          for(const line of lines){
            const s = String(line || '').trim();
            if(!s) continue;
            const split = s.split(':');
            if(split.length < 2) continue;
            const left = split.shift();
            const value = split.join(':'); // keep any colons in value

            const key = String(left || '').split(';')[0].toUpperCase();

            if(key === 'SUMMARY') summary = value;
            else if(key === 'DTSTART' || key === 'DUE') {
              const ts = parseIcsDate(value);
              if(Number.isFinite(ts)) dueVal = ts;
            }
            else if(key === 'URL') url = value;
          }

          if(!Number.isFinite(dueVal)) continue;

          out.push({
            id: 'ics_' + (base + idx) + '_' + Math.random().toString(36).slice(2,7),
            title: String(summary || 'Countdown').trim(),
            dueTs: Number(dueVal),
            createdAt: base + idx,
            completed: false,
            completedAt: null,
            archived: false,
            archivedAt: null,
            archivedReason: null,
            url: url ? String(url).trim() : null
          });

          idx += 1;
        }

        return out;
      }

      function parseTrelloJsonObjectToTasks(obj, opts = {}){
        const cards = Array.isArray(obj?.cards) ? obj.cards : null;
        if(!cards) return [];

        const out = [];
        const base = Date.now();

        const lists = Array.isArray(obj?.lists) ? obj.lists : [];
        const listNameById = new Map(lists.map(l => [String(l.id), String(l.name || '')]));
        const looksDoneList = (name) => /(^|\b)(done|complete|completed|finished|archive|archived)(\b|$)/i.test(String(name || ''));
        const includeArchived = !!opts.includeArchived;
        const includeCompleted = !!opts.includeCompleted;
        const includeUndated = !!opts.includeUndated;
        const allowedLists = opts.allowedLists instanceof Set ? opts.allowedLists : null;

        let i = 0;

        for(const card of cards){
          if(!card) continue;

          const dueRaw = card.due || card.dueDate || card.due_at || null;
          let dueTs = dueRaw ? (new Date(dueRaw)).getTime() : NaN;
          if(!Number.isFinite(dueTs)){
            if(!includeUndated) continue;
            dueTs = Date.now() + 3600e3;
          }

          const title = String(card.name || card.title || card.desc || 'Countdown').trim();
          const completed = !!card.dueComplete;
          const archived = !!card.closed;
          const listName = listNameById.get(String(card.idList || '')) || '';
          const heuristicDone = looksDoneList(listName);

          // Skip Trello cards that are already completed/archived (or in a likely-done list)
          if((completed && !includeCompleted) || ((archived || heuristicDone) && !includeArchived)) continue;
          if(allowedLists && !allowedLists.has(String(card.idList || ''))) continue;

          // Prefer Trello card creation time when possible (Trello IDs embed a timestamp)
          let createdAt = base + i;
          const idStr = String(card.id || '').trim();
          if(/^[0-9a-fA-F]{24}$/.test(idStr)){
            const secs = parseInt(idStr.slice(0, 8), 16);
            if(Number.isFinite(secs)) createdAt = secs * 1000;
          }

          out.push({
            id: String(card.id || card.shortLink || ('trello_' + (base+i))),
            title,
            dueTs,
            createdAt,
            completed,
            completedAt: completed ? Date.now() : null,
            archived,
            archivedAt: archived ? Date.now() : null,
            archivedReason: archived ? 'trello_archived' : null,
            url: String(card.shortUrl || card.url || '').trim() || null
          });

          i += 1;
        }

        return out;
      }

      function parseTrelloTextToTasks(text){
        const raw = String(text || '').trim();
        if(!raw) return [];
        if(/BEGIN:VCALENDAR/i.test(raw)) return parseIcsTextToTasks(raw);

        try{
          const obj = JSON.parse(raw);
          // Heuristic: Trello board export has `cards` array
          const maybe = parseTrelloJsonObjectToTasks(obj);
          if(maybe.length) return maybe;
        }catch(e){}

        return [];
      }

      importTrelloBtn?.addEventListener('click', () => trelloImportInput?.click());
      trelloImportInput?.addEventListener('change', async (e) => {
        const file = e?.target?.files?.[0];
        if(!file) return;
        try{
          const text = await file.text();
          let obj = null;
          try{ obj = JSON.parse(String(text||'')); }catch(_){ }
          if(obj && Array.isArray(obj.cards) && Array.isArray(obj.lists)){
            openTrelloImportModal({ raw: obj });
          } else {
            const incoming = parseTrelloTextToTasks(text);
            if(!incoming.length){
              showToast('That file didn’t look like a Trello export (.json) or calendar feed (.ics).');
            } else {
              mergeIncomingTasks(incoming, 'Trello list');
            }
          }
        } catch(err){
          showToast('Could not read that Trello file.');
        } finally {
          try{ e.target.value = ''; }catch(_){}
        }
      });




      function showTopError(message){
        if(!topError) return showToast(message);
        topError.textContent = String(message || 'Invalid file');
        topError.classList.add('show');
        clearTimeout(showTopError._t);
        showTopError._t = setTimeout(() => topError.classList.remove('show'), 2400);
      }
      ;['dragenter','dragover'].forEach(evt => document.addEventListener(evt, (e)=>{
        if(!e.dataTransfer) return;
        e.preventDefault();
      }));
      document.addEventListener('drop', async (e)=>{
        const f = e.dataTransfer?.files?.[0];
        if(!f) return;
        e.preventDefault();
        if(!/\.json$/i.test(f.name)){ showTopError('Only JSON files can be dropped here.'); return; }
        try{
          const txt = await f.text();
          const parsed = parseImportText(txt);
          if(parsed.errors?.length){ showTopError(parsed.errors[0]); return; }
          mergeIncomingTasks(parsed.tasks || [], 'Dropped file');
        }catch(_){ showTopError('Could not parse dropped JSON file.'); }
      });

      function syncStatusControls(){
        statusVisibility.task = !!statShowTask?.checked;
        statusVisibility.due = !!statShowDue?.checked;
        statusVisibility.pending = !!statShowPending?.checked;
        statusVisibility.completed = !!statShowCompleted?.checked;
        statusVisibility.missed = !!statShowMissed?.checked;
        statusVisibility.trello = !!statShowTrello?.checked;
      }
      [statShowTask,statShowDue,statShowPending,statShowCompleted,statShowMissed,statShowTrello].forEach(el => el?.addEventListener('change', ()=>{ syncStatusControls(); updateTitleAndStatus(); }));
      syncStatusControls();

      const themePresets = {
        default: { text:'#ffffff', accent:'#ffffff', panel:'#000000' },
        frost: { text:'#ffffff', accent:'#9ad1ff', panel:'#000000' },
        sunset: { text:'#ffeede', accent:'#ff8a80', panel:'#2a0f1f' },
        midnight: { text:'#d9e7ff', accent:'#7c8cff', panel:'#060912' }
      };
      let currentThemePreset = 'default';
      function syncThemePresetUI(){
        if(themePresetBtn) themePresetBtn.textContent = ({default:'Default', frost:'Frost', sunset:'Sunset', midnight:'Midnight'})[currentThemePreset] || 'Default';
        themePresetMenu?.querySelectorAll('.dropdown-item[data-value]').forEach(btn => {
          btn.setAttribute('aria-selected', btn.getAttribute('data-value') === currentThemePreset ? 'true' : 'false');
        });
      }
      function closeThemePresetDropdown(){ if(!themePresetDropdown) return; themePresetDropdown.classList.remove('open'); themePresetBtn?.setAttribute('aria-expanded','false'); }
      function openThemePresetDropdown(){ if(!themePresetDropdown) return; themePresetDropdown.classList.add('open'); themePresetBtn?.setAttribute('aria-expanded','true'); }
      function hexToRgb(hex){
        const m = String(hex || '').trim().match(/^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i);
        if(!m) return null;
        return { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16) };
      }
      function applyThemeColors(textHex, accentHex, panelHex){
        const root = document.documentElement;
        root.style.setProperty('--theme-text', textHex);
        root.style.setProperty('--theme-accent', accentHex);
        root.style.setProperty('--theme-panel', panelHex + 'd4');
        const a = hexToRgb(accentHex) || {r:154,g:209,b:255};
        root.style.setProperty('--theme-accent-soft', `rgba(${a.r}, ${a.g}, ${a.b}, 0.24)`);
        root.style.setProperty('--theme-border', `rgba(${a.r}, ${a.g}, ${a.b}, 0.36)`);
        root.style.setProperty('--theme-soft', `rgba(${a.r}, ${a.g}, ${a.b}, 0.14)`);
      }
      function applyThemePreset(id){
        currentThemePreset = themePresets[id] ? id : 'default';
        const p = themePresets[currentThemePreset];
        if(themeTextColor) themeTextColor.value = p.text;
        if(themeAccentColor) themeAccentColor.value = p.accent;
        if(themePanelColor) themePanelColor.value = p.panel;
        applyThemeColors(p.text, p.accent, p.panel);
        syncThemePresetUI();
        document.body.classList.remove('theme-shift'); void document.body.offsetWidth; document.body.classList.add('theme-shift');
        setTimeout(()=>document.body.classList.remove('theme-shift'), 420);
      }
      function applyCustomTheme(){
        currentThemePreset = 'default';
        applyThemeColors(themeTextColor?.value || '#ffffff', themeAccentColor?.value || '#ffffff', themePanelColor?.value || '#000000');
        syncThemePresetUI();
      }
      themePresetBtn?.addEventListener('click', (e) => { e.preventDefault(); if(themePresetDropdown?.classList.contains('open')) closeThemePresetDropdown(); else openThemePresetDropdown(); });
      themePresetMenu?.addEventListener('click', (e) => {
        const item = e.target.closest('.dropdown-item[data-value]');
        if(!item) return;
        applyThemePreset(item.getAttribute('data-value'));
        closeThemePresetDropdown();
      });
      document.addEventListener('click', (e)=>{ if(themePresetDropdown && !themePresetDropdown.contains(e.target)) closeThemePresetDropdown(); });
      themeTextColor?.addEventListener('input', applyCustomTheme);
      themeAccentColor?.addEventListener('input', applyCustomTheme);
      themePanelColor?.addEventListener('input', applyCustomTheme);
      applyThemePreset('default');

      let __trelloImportState = null;
      const DONE_LIST_RE = /(^|)(done|complete|completed|finished|archive|archived)(|$)/i;
      function formatDueForPreview(dueRaw){
        if(!dueRaw) return 'No due date';
        const ts = (new Date(dueRaw)).getTime();
        if(!Number.isFinite(ts)) return 'No due date';
        return new Date(ts).toLocaleString([], { month:'short', day:'numeric', hour:'2-digit', minute:'2-digit' });
      }
      function getFilteredTrelloLists(raw, opts = {}){
        const lists = Array.isArray(raw?.lists) ? raw.lists : [];
        const cards = Array.isArray(raw?.cards) ? raw.cards : [];
        const includeArchived = !!opts.includeArchived;
        const includeCompleted = !!opts.includeCompleted;
        const includeUndated = !!opts.includeUndated;

        return lists.map((l)=>{
          const listId = String(l?.id || '');
          const listName = String(l?.name || 'Untitled');
          const listArchived = !!l?.closed;
          const listLooksDone = DONE_LIST_RE.test(listName);
          const visibleCards = cards.filter((c)=>{
            if(String(c?.idList || '') !== listId) return false;
            const completed = !!c?.dueComplete;
            const archived = !!c?.closed;
            const hasDue = Number.isFinite((new Date(c?.due || c?.dueDate || c?.due_at || '')).getTime());
            if((completed && !includeCompleted) || ((archived || listArchived || listLooksDone) && !includeArchived)) return false;
            if(!hasDue && !includeUndated) return false;
            return true;
          });
          return { id:listId, name:listName, closed:listArchived, looksDone:listLooksDone, cards: visibleCards };
        }).filter((l)=> l.cards.length || includeArchived || includeCompleted || includeUndated);
      }
      function renderTrelloImportPreview(){
        if(!trelloImportLists || !__trelloImportState?.raw) return;
        const filteredLists = getFilteredTrelloLists(__trelloImportState.raw, {
          includeUndated: !!trelloIncludeUndated?.checked,
          includeArchived: !!trelloIncludeArchived?.checked,
          includeCompleted: !!trelloIncludeCompleted?.checked
        });
        trelloImportLists.innerHTML = '';
        filteredLists.forEach((lst, i)=>{
          const wrap = document.createElement('div');
          wrap.className = 'trello-list' + (i===0 ? ' open' : '');
          wrap.innerHTML = `<div class="trello-list-head"><span class="trello-arrow">▸</span><label class="check"><input type="checkbox" data-list-id="${escapeHtml(lst.id)}" checked> ${escapeHtml(lst.name)} (${lst.cards.length})</label></div><div class="trello-cards">${lst.cards.map(c => `<div class='trello-card'><div class='trello-card-title'>${escapeHtml(c.name || 'Untitled card')}</div><div class='trello-card-meta'>${escapeHtml(formatDueForPreview(c.due || c.dueDate || c.due_at || null))}</div></div>`).join('')}</div>`;
          wrap.querySelector('.trello-list-head')?.addEventListener('click', (e)=>{ if(e.target.tagName !== 'INPUT') wrap.classList.toggle('open'); });
          trelloImportLists.appendChild(wrap);
        });
        if(!filteredLists.length){
          trelloImportLists.innerHTML = `<div class="trello-card"><div class="trello-card-title">No cards match current filters</div><div class="trello-card-meta">Try enabling archived/completed or include cards without due dates.</div></div>`;
        }
      }
      function openTrelloImportModal(state){
        __trelloImportState = state;
        if(!trelloImportLists || !trelloImportModal) return;
        renderTrelloImportPreview();
        trelloImportModal.hidden = false;
        trelloImportModal.classList.add('show');
        modalBackdrop?.classList.add('show');
      }
      function closeTrelloImportModal(){
        if(trelloImportModal){ trelloImportModal.hidden = true; trelloImportModal.classList.remove('show'); }
        modalBackdrop?.classList.remove('show');
        __trelloImportState = null;
      }
      trelloIncludeUndated?.addEventListener('change', renderTrelloImportPreview);
      trelloIncludeArchived?.addEventListener('change', renderTrelloImportPreview);
      trelloIncludeCompleted?.addEventListener('change', renderTrelloImportPreview);
      trelloImportCancelBtn?.addEventListener('click', closeTrelloImportModal);
      trelloImportApplyBtn?.addEventListener('click', ()=>{
        if(!__trelloImportState) return closeTrelloImportModal();
        const selected = new Set(Array.from(trelloImportLists.querySelectorAll('input[data-list-id]:checked')).map(x => x.getAttribute('data-list-id')));
        const incoming = parseTrelloJsonObjectToTasks(__trelloImportState.raw, {
          includeUndated: !!trelloIncludeUndated?.checked,
          includeArchived: !!trelloIncludeArchived?.checked,
          includeCompleted: !!trelloIncludeCompleted?.checked,
          allowedLists: selected
        });
        if(!incoming.length) showTopError('No cards matched your selected Trello filters.');
        else mergeIncomingTasks(incoming, 'Trello list');
        closeTrelloImportModal();
      });


      completeTaskBtn?.addEventListener('click', () => {
        if (activeTask) markCompleted(activeTask.id);
      });
      skipTaskBtn?.addEventListener('click', () => {
        if (activeTask) archiveTask(activeTask.id, 'skipped');
      });
      undoLastBtn?.addEventListener('click', () => {
        const la = getLastAction();
        if (!la?.id) return;
        const t = tasks.find(x => x.id === la.id);
        if (!t) return;
        // Undo the most recent meaningful action by restoring the task.
        if (la.type === 'complete' && t.completed) restoreTask(la.id);
        else if (la.type === 'archive' && t.archived) restoreTask(la.id);
        else if (la.type === 'delete') {
          statusLine && (statusLine.innerHTML = `<span class="pill">Undo can’t restore a deleted task</span>`);
        } else if (la.type === 'clearCompleted' || la.type === 'clearMissed') {
          statusLine && (statusLine.innerHTML = `<span class="pill">Undo can’t restore cleared items</span>`);
        }
        updateMainButtons();
      });

      function renderTaskList(){
        if (!taskListEl) return;

        const pending = tasks.filter(t => !t.completed && !t.archived).sort(sortByDue);
        const completed = tasks.filter(t => !!t.completed).sort(sortByDue);
        const missed = tasks.filter(t => !!t.archived && !t.completed).sort(sortByDue);
        const pendingCounts = new Map();
        const completedCounts = new Map();
        const missedCounts = new Map();
        for(const t of pending){ const k = String(t.dueTs); pendingCounts.set(k, (pendingCounts.get(k)||0)+1); }
        for(const t of completed){ const k = String(t.dueTs); completedCounts.set(k, (completedCounts.get(k)||0)+1); }
        for(const t of missed){ const k = String(t.dueTs); missedCounts.set(k, (missedCounts.get(k)||0)+1); }


        const blocks = [];
                function row(t, badgeText, section, countsMap){
                  const due = formatDueLong(new Date(t.dueTs));
                  const isActive = activeTask && t.id === activeTask.id;
                  const badge = badgeText ? `<span class="badge">${escapeHtml(badgeText)}</span>` : '';
                  const title = escapeHtml((t.title || 'Countdown').trim());
                  const isPending = (!t.completed && !t.archived);
                  const key = String(t.dueTs);
                  const canReorder = !!(countsMap && (countsMap.get(key) || 0) > 1);
                  const handle = canReorder ? `<div class="drag-handle" draggable="true" title="Drag to reorder (same due date/time)">⋮⋮</div>` : '';
                  return `
                    <div class="task-row ${isActive ? 'is-active' : ''}" data-id="${escapeHtml(t.id)}" data-duets="${escapeHtml(String(t.dueTs))}" data-section="${escapeHtml(section||'')}">
                      <div class="task-left">
                        ${handle}
                        <div class="task-main">
                          <div class="task-title">${isActive ? '▶ ' : ''}${title}</div>
                          <div class="task-sub">
                            <span class="badge">Due: ${escapeHtml(due)}</span>
                            ${badge}
                          </div>
                        </div>
                      </div>
                      <div class="task-actions-mini">
                        ${isPending ? `
                          <button class="btn mini-btn" data-action="complete" title="Mark completed">✓</button>
                          <button class="btn ghost mini-btn" data-action="edit" title="Edit">✎</button>
                          <button class="btn ghost mini-btn" data-action="delete" title="Delete">🗑</button>
                        ` : `
                          <button class="btn ghost mini-btn" data-action="restore" title="Restore">↩</button>
                          <button class="btn ghost mini-btn" data-action="delete" title="Delete">🗑</button>
                        `}
                      </div>
                    </div>`;
                }
        if (!pending.length && !completed.length && !missed.length){
          blocks.push(`<div class="task-row"><div class="task-main"><div class="task-title">No countdowns yet</div><div class="task-sub">Add one above.</div></div></div>`);
        } else {
          if (pending.length){
            blocks.push(`<div class="task-row"><div class="task-main"><div class="task-title">Pending</div><div class="task-sub">Earliest due date is shown on the main screen.</div></div></div>`);
            pending.forEach(t => blocks.push(row(t, isFinite(t.dueTs) && t.dueTs < Date.now() ? 'Overdue' : '', 'pending', pendingCounts)));
          }
          if (completed.length){
            blocks.push(`<div class="task-row"><div class="task-main"><div class="task-title">Completed</div><div class="task-sub">Saved on this device.</div></div></div>`);
            completed.forEach(t => blocks.push(row(t, 'Completed', 'completed', completedCounts)));
            if (completed.length > 8){
              blocks.push(`<div class="task-row"><div class="task-main"><div class="task-sub">Showing 8 of ${completed.length} completed items.</div></div></div>`);
            }
          }
          if (missed.length){
            blocks.push(`<div class="task-row"><div class="task-main"><div class="task-title">Missed / Skipped</div><div class="task-sub">These are archived so the timer can move on.</div></div></div>`);
            missed.forEach(t => blocks.push(row(t, t.archivedReason || 'Missed', 'missed', missedCounts)));
            if (missed.length > 8){
              blocks.push(`<div class="task-row"><div class="task-main"><div class="task-sub">Showing 8 of ${missed.length} missed/skipped items.</div></div></div>`);
            }
          }
        }

        taskListEl.innerHTML = blocks.join('');
      }

      taskListEl?.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-action]');
        const rowEl = e.target.closest('.task-row');
        if (!btn || !rowEl) return;
        const id = rowEl.getAttribute('data-id');
        const action = btn.getAttribute('data-action');
        if (!id || !action) return;

        if (action === 'complete') markCompleted(id);
        if (action === 'restore') restoreTask(id);
        if (action === 'delete') deleteTask(id);
      });

      // ===== v4: confirmations, celebrations, editing, and smoother task motion =====
      const celebrateDropdown = document.getElementById('celebrateDropdown');
      const celebrateBtn = document.getElementById('celebrateBtn');
      const celebrateMenu = document.getElementById('celebrateMenu');
      const confettiCanvas = document.getElementById('confettiCanvas');

      const modalBackdrop = document.getElementById('modalBackdrop');

      const confirmModal = document.getElementById('confirmModal');
      const confirmTitleEl = document.getElementById('confirmTitle');
      const confirmMessageEl = document.getElementById('confirmMessage');
      const confirmCancelBtn = document.getElementById('confirmCancelBtn');
      const confirmOkBtn = document.getElementById('confirmOkBtn');

      const editModal = document.getElementById('editModal');
      const editTaskNameInput = document.getElementById('editTaskNameInput');
      const editTaskDateInput = document.getElementById('editTaskDateInput');
      const editCancelBtn = document.getElementById('editCancelBtn');
      const editSaveBtn = document.getElementById('editSaveBtn');

      let celebrateMode = (localStorage.getItem(CELEBRATE_KEY) || 'off');

      // Enforce strictly-increasing createdAt so same-due tasks keep creation order
      let lastCreatedAt = tasks.reduce((m, t) => Math.max(m, Number(t?.createdAt) || 0), 0);
      function nextCreatedAt(preferred){
        const now = Date.now();
        let cand = Number.isFinite(preferred) ? Number(preferred) : now;
        cand = Math.max(cand, now, lastCreatedAt + 1);
        lastCreatedAt = cand;
        return cand;
      }

      // Wrap addTask() to use monotonic createdAt
      if (typeof addTask === 'function') {
        const __addTask = addTask;
        addTask = function(){
          // Let the original validate inputs, but we will override createdAt/id after push.
          const beforeLen = tasks.length;
          __addTask();
          // If it added exactly one task, fix its createdAt ordering safely
          if (tasks.length === beforeLen + 1) {
            const t = tasks[tasks.length - 1];
            if (t) {
              t.createdAt = nextCreatedAt(t.createdAt);
              if (!t.id || String(t.id).indexOf('t_') !== 0) {
                t.id = 't_' + String(t.createdAt) + '_' + Math.random().toString(36).slice(2,7);
              }
              tasks.sort(sortByDue);
              saveTasks(tasks);
              setActiveFromList();
            }
          }
        };
      }

      // ---------- Themed confirm modal ----------
      function confirmAction({ title='Confirm', message='Are you sure?', okText='Confirm', cancelText='Cancel', danger=false } = {}){
        if(!confirmModal || !modalBackdrop || !confirmTitleEl || !confirmMessageEl || !confirmOkBtn || !confirmCancelBtn){
          // Fallback
          return Promise.resolve(confirm(String(message || 'Are you sure?')));
        }
        return new Promise((resolve) => {
          let done = false;
          const cleanup = () => {
            document.removeEventListener('keydown', onKey);
            modalBackdrop.removeEventListener('click', onBackdrop);
            confirmCancelBtn.removeEventListener('click', onCancel);
            confirmOkBtn.removeEventListener('click', onOk);
          };
          const close = (val) => {
            if(done) return;
            done = true;
            cleanup();
            confirmModal.classList.remove('show');
            modalBackdrop.classList.remove('show');
            confirmModal.hidden = true;
            modalBackdrop.setAttribute('aria-hidden', 'true');
            resolve(!!val);
          };
          const onKey = (e) => {
            if(e.key === 'Escape') close(false);
          };
          const onBackdrop = () => close(false);
          const onCancel = () => close(false);
          const onOk = () => close(true);

          confirmTitleEl.textContent = String(title || 'Confirm');
          confirmMessageEl.textContent = String(message || 'Are you sure?');
          confirmOkBtn.textContent = String(okText || 'Confirm');
          confirmCancelBtn.textContent = String(cancelText || 'Cancel');
          confirmOkBtn.classList.toggle('danger', !!danger);

          confirmModal.hidden = false;
          modalBackdrop.setAttribute('aria-hidden', 'false');
          // show
          modalBackdrop.classList.add('show');
          confirmModal.classList.add('show');

          document.addEventListener('keydown', onKey);
          modalBackdrop.addEventListener('click', onBackdrop);
          confirmCancelBtn.addEventListener('click', onCancel);
          confirmOkBtn.addEventListener('click', onOk);

          // focus OK for keyboard flow
          try{ confirmOkBtn.focus(); }catch(_){}
        });
      }

      // ---------- Celebration dropdown ----------
      function celebrateLabel(mode){
        switch(String(mode||'off')){
          case 'complete': return 'Completed only';
          case 'complete_skip': return 'Completed + skip';
          case 'complete_skip_missed': return 'Completed + skip + missed';
          default: return 'Off';
        }
      }
      function applyCelebrateUI(){
        if(!celebrateBtn || !celebrateMenu) return;
        celebrateBtn.textContent = celebrateLabel(celebrateMode);
        // aria selected
        celebrateMenu.querySelectorAll('.dropdown-item[data-value]').forEach(btn => {
          const v = btn.getAttribute('data-value');
          btn.setAttribute('aria-selected', String(v) === String(celebrateMode) ? 'true' : 'false');
        });
      }
      function setCelebrateMode(mode, persist=true){
        const allowed = new Set(['off','complete','complete_skip','complete_skip_missed']);
        const next = allowed.has(String(mode)) ? String(mode) : 'off';
        celebrateMode = next;
        if(persist){
          try{ localStorage.setItem(CELEBRATE_KEY, celebrateMode); }catch(_){}
        }
        applyCelebrateUI();
        // keep restore-defaults visibility accurate if it depends on UI snapshot
        try{ syncRestoreDefaultsVisibility(); }catch(_){}
      }
      setCelebrateMode(celebrateMode, false);

      function closeCelebrateDropdown(){
        if(!celebrateDropdown) return;
        celebrateDropdown.classList.remove('open');
        celebrateBtn?.setAttribute('aria-expanded','false');
      }
      function openCelebrateDropdown(){
        if(!celebrateDropdown) return;
        celebrateDropdown.classList.add('open');
        celebrateBtn?.setAttribute('aria-expanded','true');
      }
      celebrateBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        if(celebrateDropdown?.classList.contains('open')) closeCelebrateDropdown();
        else openCelebrateDropdown();
      });
      celebrateMenu?.addEventListener('click', (e) => {
        const item = e.target.closest('.dropdown-item[data-value]');
        if(!item) return;
        const v = item.getAttribute('data-value');
        setCelebrateMode(v, true);
        closeCelebrateDropdown();
      });
      document.addEventListener('click', (e) => {
        if(!celebrateDropdown) return;
        if(!celebrateDropdown.contains(e.target)) closeCelebrateDropdown();
      });
      document.addEventListener('keydown', (e) => {
        if(e.key === 'Escape') closeCelebrateDropdown();
      });

      // ---------- Background picker (Default / File / Unsplash) ----------
      const bgModeDropdown = document.getElementById('bgModeDropdown');
      const bgModeBtn = document.getElementById('bgModeBtn');
      const bgModeMenu = document.getElementById('bgModeMenu');
      const bgFilePanel = document.getElementById('bgFilePanel');
      const bgUnsplashPanel = document.getElementById('bgUnsplashPanel');

      const bgFilePathInput = document.getElementById('bgFilePathInput');
      const bgApplyFileBtn = document.getElementById('bgApplyFileBtn');
      const bgUseDefaultBtn = document.getElementById('bgUseDefaultBtn');

      const bgUnsplashKeyInput = document.getElementById('bgUnsplashKeyInput');
      const bgUnsplashKeyToggleBtn = document.getElementById('bgUnsplashKeyToggleBtn');
      const bgUnsplashQueryInput = document.getElementById('bgUnsplashQueryInput');
      const bgUnsplashSearchBtn = document.getElementById('bgUnsplashSearchBtn');
      const bgUnsplashPrevBtn = document.getElementById('bgUnsplashPrevBtn');
      const bgUnsplashNextBtn = document.getElementById('bgUnsplashNextBtn');
      const bgUnsplashFeaturedOnlyInput = document.getElementById('bgUnsplashFeaturedOnly');
      const bgUnsplashRefreshDropdown = document.getElementById('bgUnsplashRefreshDropdown');
      const bgUnsplashRefreshBtn = document.getElementById('bgUnsplashRefreshBtn');
      const bgUnsplashRefreshMenu = document.getElementById('bgUnsplashRefreshMenu');
      const bgUnsplashMinutesWrap = document.getElementById('bgUnsplashMinutesWrap');
      const bgUnsplashMinutesInput = document.getElementById('bgUnsplashMinutesInput');

      const BG_KEYS = {
        mode: 'cb_bg_mode_v1',
        file: 'cb_bg_file_v1',
        q: 'cb_bg_unsplash_q_v1',
        featured: 'cb_bg_unsplash_featured_v1',
        accessKey: 'cb_bg_unsplash_access_key_v1',
        refreshMode: 'cb_bg_unsplash_refresh_mode_v1',
        refreshMinutes: 'cb_bg_unsplash_refresh_minutes_v1',
        cache: 'cb_bg_unsplash_cache_v1',
        history: 'cb_bg_unsplash_history_v1',
        topicsCache: 'cb_bg_unsplash_featured_topics_v1'
      };

      const DEFAULT_BG = {
        mode: 'file',
        file: './Images/Photography/Forests/2.jpg',
        q: 'forest',
        featured: false,
        accessKey: '',
        refreshMode: 'newtab',     // newtab | minutes | hour | day | week
        refreshMinutes: 30
      };

      let bgMode = (localStorage.getItem(BG_KEYS.mode) || DEFAULT_BG.mode);
      let bgFilePath = (localStorage.getItem(BG_KEYS.file) || DEFAULT_BG.file);
      let bgUnsplashQuery = (localStorage.getItem(BG_KEYS.q) || DEFAULT_BG.q);
      let bgUnsplashFeaturedOnly = (localStorage.getItem(BG_KEYS.featured) === '1');
      let bgUnsplashAccessKey = (localStorage.getItem(BG_KEYS.accessKey) || DEFAULT_BG.accessKey);
      let bgUnsplashRefreshMode = (localStorage.getItem(BG_KEYS.refreshMode) || DEFAULT_BG.refreshMode);

      let bgUnsplashRefreshMinutes = parseInt(localStorage.getItem(BG_KEYS.refreshMinutes) || String(DEFAULT_BG.refreshMinutes), 10);
      if(!Number.isFinite(bgUnsplashRefreshMinutes) || bgUnsplashRefreshMinutes < 1) bgUnsplashRefreshMinutes = DEFAULT_BG.refreshMinutes;

      // History/cache are stored per "signature" (query+featuredOnly), so Next/Prev stays coherent.
      let __bgUnsplashHistory = { signature: '', index: -1, items: [] };
      let __bgUnsplashCache = {}; // signature -> { ts, photoId, url, rawUrl, credit }
      let __bgUnsplashTopicsCache = { ts: 0, topics: [] };
      let __bgUnsplashAutoTimer = null;
      let __bgUnsplashForceNext = false;

      try{
        const h = JSON.parse(localStorage.getItem(BG_KEYS.history) || 'null');
        if(h && typeof h === 'object' && Array.isArray(h.items)) __bgUnsplashHistory = h;
      }catch(_){}
      try{
        const c = JSON.parse(localStorage.getItem(BG_KEYS.cache) || 'null');
        if(c && typeof c === 'object') __bgUnsplashCache = c;
      }catch(_){}
      try{
        const t = JSON.parse(localStorage.getItem(BG_KEYS.topicsCache) || 'null');
        if(t && typeof t === 'object' && Array.isArray(t.topics)) __bgUnsplashTopicsCache = t;
      }catch(_){}

            function bgModeLabel(mode){
        switch(String(mode||'default')){
          case 'file': return 'Choose from file path';
          case 'unsplash': return 'Choose from Unsplash';
          default: return 'None (use default)';
        }
      }

      function bgRefreshLabel(mode, minutes){
        const m = Math.max(1, parseInt(minutes || DEFAULT_BG.refreshMinutes, 10) || DEFAULT_BG.refreshMinutes);
        switch(String(mode||'newtab')){
          case 'minutes': return `Change image: Every ${m} min`;
          case 'hour': return 'Change image: Every hour';
          case 'day': return 'Change image: Every day';
          case 'week': return 'Change image: Every week';
          default: return 'Change image: On open';
        }
      }

      function setCssBgImg(urlOrNull){
        const root = document.documentElement;
        if(urlOrNull){
          const safe = String(urlOrNull).replace(/"/g, '%22');
          root.style.setProperty('--bg-img', `url("${safe}")`);
          document.body.classList.remove('default-bg');
        } else {
          root.style.setProperty('--bg-img', 'none');
          document.body.classList.add('default-bg');
        }
      }

      function preloadImage(url){
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(true);
          img.onerror = () => reject(new Error('bg_load_failed'));
          img.src = url;
        });
      }

      function getViewportPx(){
        const dpr = Math.max(1, Math.min(2, Number(window.devicePixelRatio) || 1));
        const w = Math.max(320, Math.min(3840, Math.round(window.innerWidth * dpr)));
        const h = Math.max(320, Math.min(3840, Math.round(window.innerHeight * dpr)));
        return { w, h, dpr };
      }

      function currentUnsplashSignature(){
        const q = String(bgUnsplashQuery || DEFAULT_BG.q).trim() || DEFAULT_BG.q;
        if(bgUnsplashFeaturedOnly) return 'featured';
        return 'query:' + q.toLowerCase();
      }

      function getUnsplashIntervalMs(){
        const mode = String(bgUnsplashRefreshMode || DEFAULT_BG.refreshMode);
        const mins = Math.max(1, parseInt(bgUnsplashRefreshMinutes || DEFAULT_BG.refreshMinutes, 10) || DEFAULT_BG.refreshMinutes);
        if(mode === 'minutes') return mins * 60 * 1000;
        if(mode === 'hour') return 60 * 60 * 1000;
        if(mode === 'day') return 24 * 60 * 60 * 1000;
        if(mode === 'week') return 7 * 24 * 60 * 60 * 1000;
        return 0; // newtab
      }

      function unsplashSetCredit(credit){
        const el = document.getElementById('unsplashCredit');
        if(!el) return;

        if(!credit){
          el.classList.remove('show');
          el.hidden = true;
          el.replaceChildren();
          return;
        }

        el.hidden = false;
        el.replaceChildren();

        const span1 = document.createTextNode('');

        const aUser = document.createElement('a');
        aUser.href = credit.photoUrl || 'https://unsplash.com';
        aUser.target = '_blank';
        aUser.rel = 'noopener noreferrer';
        aUser.textContent = 'Photo';
        const sepAuthor1 = document.createTextNode(' by ');
        const aAuthor = document.createElement('a');
        aAuthor.href = credit.userUrl || 'https://unsplash.com';
        aAuthor.target = '_blank';
        aAuthor.rel = 'noopener noreferrer';
        aAuthor.textContent = credit.userName || 'Unknown';
        const sepAuthor2 = document.createTextNode(' on ');

                const aUnsplash = document.createElement('a');
        aUnsplash.href = credit.unsplashUrl || 'https://unsplash.com';
        aUnsplash.target = '_blank';
        aUnsplash.rel = 'noopener noreferrer';
        aUnsplash.textContent = 'Unsplash';

        el.append(span1, aUser, sepAuthor1, aAuthor, sepAuthor2, aUnsplash);
        requestAnimationFrame(() => el.classList.add('show'));
      }

      function buildUnsplashCreditFromPhoto(photo){
        const user = photo && photo.user ? photo.user : null;
        const links = photo && photo.links ? photo.links : null;
        const userName = (user && (user.name || user.username)) ? String(user.name || user.username) : 'Unknown';
        const userUrl = (user && user.links && user.links.html) ? String(user.links.html) : (user && user.username ? `https://unsplash.com/@${user.username}` : 'https://unsplash.com');
        const photoUrl = (links && links.html) ? String(links.html) : 'https://unsplash.com';
        // Keep attribution simple & compliant: link to photographer and Unsplash.
        return { userName, userUrl, photoUrl, unsplashUrl: 'https://unsplash.com' };
      }

      function buildUnsplashImgUrl(rawUrl){
        const { w, h, dpr } = getViewportPx();
        try{
          const u = new URL(String(rawUrl));
          u.searchParams.set('w', String(w));
          u.searchParams.set('h', String(h));
          u.searchParams.set('fit', 'crop');
          u.searchParams.set('crop', 'entropy');
          u.searchParams.set('auto', 'format');
          u.searchParams.set('q', '80');
          u.searchParams.set('dpr', String(dpr));
          return u.toString();
        }catch(_){
          return String(rawUrl || '');
        }
      }

      async function unsplashJson(endpoint, params = {}){
        const key = String(bgUnsplashAccessKey || '').trim();
        if(!key) throw new Error('unsplash_no_key');

        const u = new URL('https://api.unsplash.com' + endpoint);
        Object.entries(params || {}).forEach(([k,v]) => {
          if(v === undefined || v === null) return;
          const s = String(v).trim();
          if(!s) return;
          u.searchParams.set(k, s);
        });
        u.searchParams.set('client_id', key);

        const res = await fetch(u.toString(), { headers: { 'Accept-Version': 'v1' } });
        if(res.status === 401 || res.status === 403) throw new Error('unsplash_auth');
        if(res.status === 429) throw new Error('unsplash_rate');
        if(!res.ok) throw new Error('unsplash_http_' + res.status);

        return await res.json();
      }

      async function getFeaturedTopics(){
        const key = String(bgUnsplashAccessKey || '').trim();
        if(!key) throw new Error('unsplash_no_key');

        const now = Date.now();
        const weekMs = 7 * 24 * 60 * 60 * 1000;

        if(__bgUnsplashTopicsCache && Array.isArray(__bgUnsplashTopicsCache.topics) && __bgUnsplashTopicsCache.topics.length && (now - (Number(__bgUnsplashTopicsCache.ts)||0) < weekMs)){
          return __bgUnsplashTopicsCache.topics;
        }

        // "order_by=featured" is supported for topics list.
        const topics = await unsplashJson('/topics', { per_page: 30, order_by: 'featured' });
        const cleaned = (Array.isArray(topics) ? topics : []).map(t => ({
          id: t && t.id ? String(t.id) : '',
          slug: t && t.slug ? String(t.slug) : '',
          title: t && t.title ? String(t.title) : ''
        })).filter(t => t.id);

        __bgUnsplashTopicsCache = { ts: now, topics: cleaned };
        try{ localStorage.setItem(BG_KEYS.topicsCache, JSON.stringify(__bgUnsplashTopicsCache)); }catch(_){}
        return cleaned;
      }

      function pickFeaturedTopicId(topics){
        if(!Array.isArray(topics) || !topics.length) return '';
        const wallpapers = topics.find(t => String(t.slug) === 'wallpapers') || null;
        if(wallpapers && Math.random() < 0.60) return wallpapers.id; // bias to wallpapers for cleaner backgrounds
        return topics[Math.floor(Math.random() * topics.length)].id;
      }

      async function trackUnsplashDownload(photo){
        const key = String(bgUnsplashAccessKey || '').trim();
        const dl = photo && photo.links && photo.links.download_location ? String(photo.links.download_location) : '';
        if(!key || !dl) return;
        try{
          const u = new URL(dl);
          u.searchParams.set('client_id', key);
          fetch(u.toString(), { headers: { 'Accept-Version': 'v1' } }).catch(()=>{});
        }catch(_){}
      }

      function getUnsplashOrientation(){
        return (window.innerWidth >= window.innerHeight) ? 'landscape' : 'portrait';
      }

      async function fetchNewUnsplashRecord(){
        const orientation = getUnsplashOrientation();

        let photo = null;
        if(bgUnsplashFeaturedOnly){
          // Random photo from a random "featured topic" pool.
          const topics = await getFeaturedTopics();
          const topicId = pickFeaturedTopicId(topics);
          if(!topicId) throw new Error('unsplash_no_topics');
          photo = await unsplashJson('/photos/random', { topics: topicId, orientation });
        } else {
          const q = String(bgUnsplashQuery || DEFAULT_BG.q).trim() || DEFAULT_BG.q;
          photo = await unsplashJson('/photos/random', { query: q, orientation });
        }

        const rawUrl = photo && photo.urls && photo.urls.raw ? String(photo.urls.raw) : (photo && photo.urls && (photo.urls.full || photo.urls.regular) ? String(photo.urls.full || photo.urls.regular) : '');
        const url = buildUnsplashImgUrl(rawUrl);
        const credit = buildUnsplashCreditFromPhoto(photo);

        const rec = {
          ts: Date.now(),
          photoId: photo && photo.id ? String(photo.id) : '',
          url,
          rawUrl,
          credit
        };

        // Best-effort download tracking for API guidelines.
        trackUnsplashDownload(photo);

        return rec;
      }

      function ensureUnsplashHistorySignature(sig){
        if(!__bgUnsplashHistory || typeof __bgUnsplashHistory !== 'object') __bgUnsplashHistory = { signature: '', index: -1, items: [] };
        if(String(__bgUnsplashHistory.signature || '') !== String(sig)){
          __bgUnsplashHistory = { signature: String(sig), index: -1, items: [] };
        }
        if(!Array.isArray(__bgUnsplashHistory.items)) __bgUnsplashHistory.items = [];
        if(!Number.isFinite(Number(__bgUnsplashHistory.index))) __bgUnsplashHistory.index = __bgUnsplashHistory.items.length - 1;
      }

      function getCurrentUnsplashRecord(){
        const sig = currentUnsplashSignature();
        ensureUnsplashHistorySignature(sig);
        const idx = Number(__bgUnsplashHistory.index);
        if(idx >= 0 && idx < __bgUnsplashHistory.items.length) return __bgUnsplashHistory.items[idx];
        return (__bgUnsplashCache && __bgUnsplashCache[sig]) ? __bgUnsplashCache[sig] : null;
      }

      async function applyUnsplashRecord(rec, {quiet=false} = {}){
        if(!rec || !rec.url){
          setCssBgImg(null);
          unsplashSetCredit(null);
          return;
        }
        try{
          await preloadImage(rec.url);
          setCssBgImg(rec.url);
          unsplashSetCredit(rec.credit || null);
        }catch(_){
          setCssBgImg(null);
          unsplashSetCredit(null);
          if(!quiet) showToast('Could not load that Unsplash image — using the default background.');
        }
      }

      function scheduleUnsplashAutoRefresh(){
        clearTimeout(__bgUnsplashAutoTimer);
        __bgUnsplashAutoTimer = null;

        if(String(bgMode) !== 'unsplash') return;

        const interval = getUnsplashIntervalMs();
        if(!interval) return;

        const sig = currentUnsplashSignature();
        const rec = (__bgUnsplashCache && __bgUnsplashCache[sig]) ? __bgUnsplashCache[sig] : null;
        const lastTs = rec && rec.ts ? Number(rec.ts) : 0;
        const elapsed = lastTs ? (Date.now() - lastTs) : interval;
        const remaining = Math.max(1500, interval - elapsed);

        __bgUnsplashAutoTimer = setTimeout(async () => {
          if(String(bgMode) !== 'unsplash') return;
          try{
            await applyUnsplashBackground({ forceNew: true, quiet: true });
          }catch(_){}
        }, remaining);
      }

      async function applyUnsplashBackground({ forceNew=false, quiet=false } = {}){
        if(__bgUnsplashForceNext){
          forceNew = true;
          __bgUnsplashForceNext = false;
        }
        const sig = currentUnsplashSignature();
        ensureUnsplashHistorySignature(sig);

        const interval = getUnsplashIntervalMs();
        const cached = (__bgUnsplashCache && __bgUnsplashCache[sig]) ? __bgUnsplashCache[sig] : null;

        const expired = (interval && cached && cached.ts) ? (Date.now() - Number(cached.ts) >= interval) : false;
        const shouldFetch = forceNew || !cached || (interval ? expired : true);

        if(!shouldFetch && cached){
          await applyUnsplashRecord(cached, {quiet});
          scheduleUnsplashAutoRefresh();
          return;
        }

        const rec = await fetchNewUnsplashRecord();
        await applyUnsplashRecord(rec, {quiet});

        __bgUnsplashCache[sig] = rec;

        // Next/Prev history: truncate forward history if you "branch"
        if(__bgUnsplashHistory.index < __bgUnsplashHistory.items.length - 1){
          __bgUnsplashHistory.items = __bgUnsplashHistory.items.slice(0, __bgUnsplashHistory.index + 1);
        }
        __bgUnsplashHistory.items.push(rec);
        if(__bgUnsplashHistory.items.length > 30) __bgUnsplashHistory.items.shift();
        __bgUnsplashHistory.index = __bgUnsplashHistory.items.length - 1;

        scheduleUnsplashAutoRefresh();
      }

      async function recropUnsplashCurrent({quiet=true} = {}){
        if(String(bgMode) !== 'unsplash') return;
        const rec = getCurrentUnsplashRecord();
        if(!rec || !rec.rawUrl) return;

        const newUrl = buildUnsplashImgUrl(rec.rawUrl);
        if(!newUrl || newUrl === rec.url) return;

        const next = { ...rec, url: newUrl };
        // Update cache + history record in-place
        const sig = currentUnsplashSignature();
        if(__bgUnsplashCache && __bgUnsplashCache[sig] && __bgUnsplashCache[sig].photoId === rec.photoId){
          __bgUnsplashCache[sig] = next;
        }
        if(__bgUnsplashHistory && Array.isArray(__bgUnsplashHistory.items)){
          const idx = Number(__bgUnsplashHistory.index);
          if(idx >= 0 && idx < __bgUnsplashHistory.items.length && __bgUnsplashHistory.items[idx].photoId === rec.photoId){
            __bgUnsplashHistory.items[idx] = next;
          }
        }

        await applyUnsplashRecord(next, {quiet});
      }


      function persistBg(){
        try{
          localStorage.setItem(BG_KEYS.mode, String(bgMode));
          localStorage.setItem(BG_KEYS.file, String(bgFilePath || ''));
          localStorage.setItem(BG_KEYS.q, String(bgUnsplashQuery || ''));
          localStorage.setItem(BG_KEYS.featured, bgUnsplashFeaturedOnly ? '1' : '0');
          localStorage.setItem(BG_KEYS.accessKey, String(bgUnsplashAccessKey || ''));
          localStorage.setItem(BG_KEYS.refreshMode, String(bgUnsplashRefreshMode || DEFAULT_BG.refreshMode));
          localStorage.setItem(BG_KEYS.refreshMinutes, String(bgUnsplashRefreshMinutes || DEFAULT_BG.refreshMinutes));
          localStorage.setItem(BG_KEYS.history, JSON.stringify(__bgUnsplashHistory));
          localStorage.setItem(BG_KEYS.cache, JSON.stringify(__bgUnsplashCache));
          localStorage.setItem(BG_KEYS.topicsCache, JSON.stringify(__bgUnsplashTopicsCache));
        }catch(_){}
        try{ syncRestoreDefaultsVisibility(); }catch(_){}
      }


      function syncBgPanels(){
        const showFile = String(bgMode) === 'file';
        const showUnsplash = String(bgMode) === 'unsplash';
        bgFilePanel?.classList.toggle('show', showFile);
        bgUnsplashPanel?.classList.toggle('show', showUnsplash);

        if(bgFilePathInput && bgFilePathInput.value !== String(bgFilePath || '')) bgFilePathInput.value = String(bgFilePath || '');
        if(bgUnsplashQueryInput && bgUnsplashQueryInput.value !== String(bgUnsplashQuery || '')) bgUnsplashQueryInput.value = String(bgUnsplashQuery || '');
        if(bgUnsplashFeaturedOnlyInput) bgUnsplashFeaturedOnlyInput.checked = !!bgUnsplashFeaturedOnly;

        if(bgUnsplashKeyInput && bgUnsplashKeyInput.value !== String(bgUnsplashAccessKey || '')) bgUnsplashKeyInput.value = String(bgUnsplashAccessKey || '');

        if(bgUnsplashMinutesInput) bgUnsplashMinutesInput.value = String(bgUnsplashRefreshMinutes || DEFAULT_BG.refreshMinutes);
        if(bgUnsplashMinutesWrap) bgUnsplashMinutesWrap.style.display = (String(bgUnsplashRefreshMode) === 'minutes') ? 'flex' : 'none';

        if(bgUnsplashRefreshBtn) bgUnsplashRefreshBtn.textContent = bgRefreshLabel(bgUnsplashRefreshMode, bgUnsplashRefreshMinutes);
        if(bgUnsplashRefreshMenu){
          bgUnsplashRefreshMenu.querySelectorAll('.dropdown-item[data-value]').forEach(btn => {
            const v = btn.getAttribute('data-value');
            btn.setAttribute('aria-selected', String(v) === String(bgUnsplashRefreshMode) ? 'true' : 'false');
          });
        }
      }


      function applyBgDropdownUI(){
        if(!bgModeBtn || !bgModeMenu) return;
        bgModeBtn.textContent = bgModeLabel(bgMode);
        bgModeMenu.querySelectorAll('.dropdown-item[data-value]').forEach(btn => {
          const v = btn.getAttribute('data-value');
          btn.setAttribute('aria-selected', String(v) === String(bgMode) ? 'true' : 'false');
        });
      }

      async function applyBackground({ persist=true, quiet=false } = {}){
        syncBgPanels();
        applyBgDropdownUI();

        if(String(bgMode) === 'default'){
          setCssBgImg(null);
          unsplashSetCredit(null);
          if(persist) persistBg();
          return;
        }

        if(String(bgMode) === 'file'){
          unsplashSetCredit(null);
          const path = String(bgFilePath || '').trim();
          if(!path){
            setCssBgImg(null);
            if(persist) persistBg();
            return;
          }
          try{
            await preloadImage(path);
            setCssBgImg(path);
          }catch(_){
            setCssBgImg(null);
            unsplashSetCredit(null);
            if(!quiet) showToast('Could not load that file path — using the default background.');
          }
          if(persist) persistBg();
          return;
        }

        if(String(bgMode) === 'unsplash'){
          try{
            await applyUnsplashBackground({ forceNew: false, quiet });
          }catch(err){
            setCssBgImg(null);
            unsplashSetCredit(null);

            const code = (err && err.message) ? String(err.message) : '';
            if(!quiet){
              if(code === 'unsplash_no_key'){
                showToast('Unsplash needs an Access Key. Paste your Unsplash Access Key (Client ID) in the Unsplash panel.');
              } else if(code === 'unsplash_auth'){
                showToast('Unsplash rejected that Access Key. Double-check your Client ID.');
              } else if(code === 'unsplash_rate'){
                showToast('Unsplash rate limit hit. Try again in a bit.');
              } else {
                showToast('Could not load Unsplash — using the default background.');
              }
            }
          }
          if(persist) persistBg();
          return;
        }

      }

      function closeBgDropdown(){
        if(!bgModeDropdown) return;
        bgModeDropdown.classList.remove('open');
        bgModeBtn?.setAttribute('aria-expanded','false');
      }
      function openBgDropdown(){
        if(!bgModeDropdown) return;
        bgModeDropdown.classList.add('open');
        bgModeBtn?.setAttribute('aria-expanded','true');
      }

      bgModeBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        if(bgModeDropdown?.classList.contains('open')) closeBgDropdown();
        else openBgDropdown();
      });
      bgModeMenu?.addEventListener('click', async (e) => {
        const item = e.target.closest('.dropdown-item[data-value]');
        if(!item) return;
        const v = item.getAttribute('data-value');
        bgMode = String(v || 'default');
        closeBgDropdown();
        await applyBackground({ persist: true, quiet: true });
      });
      document.addEventListener('click', (e) => {
        if(!bgModeDropdown) return;
        if(!bgModeDropdown.contains(e.target)) closeBgDropdown();
      });
      document.addEventListener('keydown', (e) => {
        if(e.key === 'Escape') closeBgDropdown();
      });

      bgApplyFileBtn?.addEventListener('click', async () => {
        bgMode = 'file';
        bgFilePath = String(bgFilePathInput?.value || '').trim();
        await applyBackground({ persist: true, quiet: false });
      });
      bgUseDefaultBtn?.addEventListener('click', async () => {
        bgMode = 'default';
        await applyBackground({ persist: true, quiet: true });
      });

            // Unsplash: key + refresh controls + navigation
      if(bgUnsplashKeyInput){
        bgUnsplashKeyInput.value = String(bgUnsplashAccessKey || '');
        bgUnsplashKeyInput.addEventListener('input', () => {
          bgUnsplashAccessKey = String(bgUnsplashKeyInput.value || '').trim();
          persistBg();
        });
      }
      bgUnsplashKeyToggleBtn?.addEventListener('click', () => {
        if(!bgUnsplashKeyInput) return;
        const isPw = (bgUnsplashKeyInput.type === 'password');
        bgUnsplashKeyInput.type = isPw ? 'text' : 'password';
        bgUnsplashKeyToggleBtn.textContent = isPw ? 'Hide' : 'Show';
      });

      function closeUnsplashRefreshDropdown(){
        if(!bgUnsplashRefreshDropdown) return;
        bgUnsplashRefreshDropdown.classList.remove('open');
        bgUnsplashRefreshBtn?.setAttribute('aria-expanded','false');
      }
      function openUnsplashRefreshDropdown(){
        if(!bgUnsplashRefreshDropdown) return;
        bgUnsplashRefreshDropdown.classList.add('open');
        bgUnsplashRefreshBtn?.setAttribute('aria-expanded','true');
      }

      bgUnsplashRefreshBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        if(bgUnsplashRefreshDropdown?.classList.contains('open')) closeUnsplashRefreshDropdown();
        else openUnsplashRefreshDropdown();
      });

      bgUnsplashRefreshMenu?.addEventListener('click', async (e) => {
        const item = e.target.closest('.dropdown-item[data-value]');
        if(!item) return;
        const v = item.getAttribute('data-value') || DEFAULT_BG.refreshMode;

        bgUnsplashRefreshMode = String(v);
        closeUnsplashRefreshDropdown();
        syncBgPanels();
        persistBg();

        if(String(bgMode) === 'unsplash'){
          scheduleUnsplashAutoRefresh();
          // If you switch to a timed mode and it's already "due", refresh now.
          const interval = getUnsplashIntervalMs();
          const sig = currentUnsplashSignature();
          const rec = (__bgUnsplashCache && __bgUnsplashCache[sig]) ? __bgUnsplashCache[sig] : null;
          if(interval && rec && rec.ts && (Date.now() - Number(rec.ts) >= interval)){
            __bgUnsplashForceNext = true;
            await applyBackground({ persist: true, quiet: true });
          }
        }
      });

      document.addEventListener('click', (e) => {
        if(!bgUnsplashRefreshDropdown) return;
        if(!bgUnsplashRefreshDropdown.contains(e.target)) closeUnsplashRefreshDropdown();
      });
      document.addEventListener('keydown', (e) => {
        if(e.key === 'Escape') closeUnsplashRefreshDropdown();
      });

      bgUnsplashMinutesInput?.addEventListener('input', () => {
        const n = Math.max(1, Math.min(1440, parseInt(bgUnsplashMinutesInput.value || '30', 10) || DEFAULT_BG.refreshMinutes));
        bgUnsplashRefreshMinutes = n;
        syncBgPanels();
        persistBg();
        if(String(bgMode) === 'unsplash') scheduleUnsplashAutoRefresh();
      });

      bgUnsplashSearchBtn?.addEventListener('click', async () => {
        bgMode = 'unsplash';
        bgUnsplashQuery = String(bgUnsplashQueryInput?.value || '').trim() || DEFAULT_BG.q;

        // Force a new fetch on click (even if you're on hour/day/week and the cached image isn't "expired" yet).
        __bgUnsplashForceNext = true;

        // Reset history when you change the "signature"
        const sig = currentUnsplashSignature();
        __bgUnsplashHistory = { signature: String(sig), index: -1, items: [] };

        await applyBackground({ persist: true, quiet: false });
      });

      bgUnsplashNextBtn?.addEventListener('click', async () => {
        bgMode = 'unsplash';
        bgUnsplashQuery = String(bgUnsplashQueryInput?.value || bgUnsplashQuery || DEFAULT_BG.q).trim() || DEFAULT_BG.q;

        __bgUnsplashForceNext = true;
        await applyBackground({ persist: true, quiet: false });
      });

      bgUnsplashPrevBtn?.addEventListener('click', async () => {
        bgMode = 'unsplash';
        bgUnsplashQuery = String(bgUnsplashQueryInput?.value || bgUnsplashQuery || DEFAULT_BG.q).trim() || DEFAULT_BG.q;

        const sig = currentUnsplashSignature();
        ensureUnsplashHistorySignature(sig);

        if(__bgUnsplashHistory.index > 0){
          __bgUnsplashHistory.index = Math.max(0, __bgUnsplashHistory.index - 1);
          const rec = __bgUnsplashHistory.items[__bgUnsplashHistory.index];
          await applyUnsplashRecord(rec, {quiet:false});
          scheduleUnsplashAutoRefresh();
          persistBg();
        } else {
          showToast('No previous Unsplash image yet.');
        }
      });

      bgUnsplashFeaturedOnlyInput?.addEventListener('change', async () => {
        bgMode = 'unsplash';
        bgUnsplashFeaturedOnly = !!bgUnsplashFeaturedOnlyInput.checked;

        // Featured mode changes the signature; reset history and fetch fresh.
        __bgUnsplashForceNext = true;
        const sig = currentUnsplashSignature();
        __bgUnsplashHistory = { signature: String(sig), index: -1, items: [] };

        await applyBackground({ persist: true, quiet: false });
      });

      // Re-crop current Unsplash image on resize (same photo, new dimensions).
      let __bgResizeTimer = null;
      window.addEventListener('resize', () => {
        if(String(bgMode) !== 'unsplash') return;
        clearTimeout(__bgResizeTimer);
        __bgResizeTimer = setTimeout(() => {
          recropUnsplashCurrent({ quiet: true });
          try{ persistBg(); }catch(_){}
        }, 220);
      });

      // If you come back to the tab and a timed refresh is due, refresh.
      document.addEventListener('visibilitychange', () => {
        if(document.visibilityState !== 'visible') return;
        if(String(bgMode) !== 'unsplash') return;

        const interval = getUnsplashIntervalMs();
        if(!interval) return;

        const sig = currentUnsplashSignature();
        const rec = (__bgUnsplashCache && __bgUnsplashCache[sig]) ? __bgUnsplashCache[sig] : null;
        if(rec && rec.ts && (Date.now() - Number(rec.ts) >= interval)){
          __bgUnsplashForceNext = true;
          applyBackground({ persist: true, quiet: true });
        }
      });

// Apply background on load (quietly)
      try{
        // Make sure the default animation can kick in immediately if needed.
        document.body.classList.add('default-bg');
      }catch(_){}
      applyBackground({ persist: false, quiet: true });


      // Ensure startup settings include celebration
      try{
        const __getSnap = getCurrentUISnapshot;
        getCurrentUISnapshot = function(){
          const s = __getSnap();
          s.celebrateMode = celebrateMode;
          s.bgMode = bgMode;
          s.bgFilePath = bgFilePath;
          s.bgUnsplashQuery = bgUnsplashQuery;
          s.bgUnsplashFeaturedOnly = bgUnsplashFeaturedOnly;
          s.bgUnsplashAccessKey = bgUnsplashAccessKey;
          s.bgUnsplashRefreshMode = bgUnsplashRefreshMode;
          s.bgUnsplashRefreshMinutes = bgUnsplashRefreshMinutes;
          return s;
        };
      }catch(_){}
      try{
        const __applySnap = applyUISnapshot;
        applyUISnapshot = function(snap, opts){
          __applySnap(snap, opts);
          if(snap && snap.celebrateMode !== undefined){
            setCelebrateMode(snap.celebrateMode, true);
          }
          if(snap && (
            snap.bgMode !== undefined ||
            snap.bgFilePath !== undefined ||
            snap.bgUnsplashQuery !== undefined ||
            snap.bgUnsplashFeaturedOnly !== undefined ||
            snap.bgUnsplashAccessKey !== undefined ||
            snap.bgUnsplashRefreshMode !== undefined ||
            snap.bgUnsplashRefreshMinutes !== undefined
          )){
            try{
              if(snap.bgMode !== undefined) bgMode = String(snap.bgMode);
              if(snap.bgFilePath !== undefined) bgFilePath = String(snap.bgFilePath);
              if(snap.bgUnsplashQuery !== undefined) bgUnsplashQuery = String(snap.bgUnsplashQuery);
              if(snap.bgUnsplashFeaturedOnly !== undefined) bgUnsplashFeaturedOnly = !!snap.bgUnsplashFeaturedOnly;
              if(snap.bgUnsplashAccessKey !== undefined) bgUnsplashAccessKey = String(snap.bgUnsplashAccessKey || '');
              if(snap.bgUnsplashRefreshMode !== undefined) bgUnsplashRefreshMode = String(snap.bgUnsplashRefreshMode || DEFAULT_BG.refreshMode);

              if(snap.bgUnsplashRefreshMinutes !== undefined){
                const v = parseInt(snap.bgUnsplashRefreshMinutes, 10);
                if(Number.isFinite(v) && v > 0) bgUnsplashRefreshMinutes = v;
              }

              // Apply and persist background (this matches "save preferences")
              applyBackground({ persist: true, quiet: true });
            }catch(_){}
          }
        };
      }catch(_){}

      // Restore defaults should clear celebration preference too
      if(typeof restoreDefaults === 'function'){
        const __restoreDefaults = restoreDefaults;
        restoreDefaults = function(){
          confirmAction({
            title: 'Restore defaults?',
            message: 'This will revert all your settings to the default.\nYour countdown tasks will not be changed.',
            okText: 'Restore',
            cancelText: 'Cancel',
            danger: true
          }).then(ok => {
            if(!ok) return;
                        try{ localStorage.removeItem(CELEBRATE_KEY); }catch(_){}
            celebrateMode = 'off';
            applyCelebrateUI();

            // v6: also restore background prefs
            try{
              localStorage.removeItem(BG_KEYS.mode);
              localStorage.removeItem(BG_KEYS.file);
              localStorage.removeItem(BG_KEYS.q);
              localStorage.removeItem(BG_KEYS.featured);
              localStorage.removeItem(BG_KEYS.accessKey);
              localStorage.removeItem(BG_KEYS.refreshMode);
              localStorage.removeItem(BG_KEYS.refreshMinutes);
              localStorage.removeItem(BG_KEYS.cache);
              localStorage.removeItem(BG_KEYS.history);
              localStorage.removeItem(BG_KEYS.topicsCache);
            }catch(_){}
            try{
              bgMode = DEFAULT_BG.mode;
              bgFilePath = DEFAULT_BG.file;
              bgUnsplashQuery = DEFAULT_BG.q;
              bgUnsplashFeaturedOnly = !!DEFAULT_BG.featured;
              bgUnsplashAccessKey = String(DEFAULT_BG.accessKey || '');
              bgUnsplashRefreshMode = String(DEFAULT_BG.refreshMode || 'newtab');
              bgUnsplashRefreshMinutes = parseInt(DEFAULT_BG.refreshMinutes, 10) || 30;
              __bgUnsplashCache = {};
              __bgUnsplashHistory = { signature: '', index: -1, items: [] };
              __bgUnsplashTopicsCache = { ts: 0, topics: [] };
              applyBackground({ persist: true, quiet: true });
            }catch(_){}

            __restoreDefaults();
          });
        };
      }

      // Clear completed / missed confirmations
      if(typeof clearCompleted === 'function'){
        const __clearCompleted = clearCompleted;
        clearCompleted = function(){
          const count = Array.isArray(tasks) ? tasks.filter(t => t && t.completed).length : 0;
          confirmAction({
            title: 'Clear completed?',
            message: `This will permanently remove ${count} completed task${count === 1 ? '' : 's'} from this page on this device.
This cannot be undone.`,
            okText: 'Clear completed',
            cancelText: 'Cancel',
            danger: true
          }).then(ok => { if(ok) __clearCompleted(); });
        };
      }
      if(typeof clearMissed === 'function'){
        const __clearMissed = clearMissed;
        clearMissed = function(){
          const count = Array.isArray(tasks) ? tasks.filter(t => t && t.archived && !t.completed).length : 0;
          confirmAction({
            title: 'Clear missed / skipped?',
            message: `This will permanently remove ${count} missed/skipped task${count === 1 ? '' : 's'} from your missed/skipped history on this device.
This cannot be undone.`,
            okText: 'Clear missed/skipped',
            cancelText: 'Cancel',
            danger: true
          }).then(ok => { if(ok) __clearMissed(); });
        };
      }

      // ---------- Confetti ----------
      const prefersReducedMotionV4 = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      let confettiRAF = null;
      function fireConfetti(){
        if(!confettiCanvas || prefersReducedMotionV4) return;
        const ctx = confettiCanvas.getContext('2d');
        if(!ctx) return;

        // Resize to device pixels
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const w = Math.floor(window.innerWidth * dpr);
        const h = Math.floor(window.innerHeight * dpr);
        if(confettiCanvas.width !== w) confettiCanvas.width = w;
        if(confettiCanvas.height !== h) confettiCanvas.height = h;

        const now = performance.now();
        const duration = 1200;
        const particles = [];
        const colors = ['#ff4d6d','#ffd166','#06d6a0','#4cc9f0','#c77dff','#f77f00','#00b4d8'];

        const count = 90;
        for(let i=0;i<count;i++){
          particles.push({
            x: w * (0.2 + 0.6*Math.random()),
            y: h * (0.12 + 0.08*Math.random()),
            vx: (Math.random()*2-1) * 6 * dpr,
            vy: (Math.random()*-1) * 10 * dpr - 2*dpr,
            g: (0.55 + Math.random()*0.7) * dpr,
            s: (2 + Math.random()*3) * dpr,
            r: Math.random()*Math.PI,
            vr: (Math.random()*2-1)*0.25,
            c: colors[(Math.random()*colors.length)|0],
            a: 1
          });
        }

        confettiCanvas.classList.add('is-on');
        const tick = (t) => {
          const elapsed = t - now;
          const p = Math.min(1, elapsed / duration);
          ctx.clearRect(0,0,w,h);
          for(const q of particles){
            q.vy += q.g;
            q.x += q.vx;
            q.y += q.vy;
            q.r += q.vr;
            q.a = 1 - p;
            ctx.globalAlpha = Math.max(0, q.a);
            ctx.save();
            ctx.translate(q.x, q.y);
            ctx.rotate(q.r);
            ctx.fillStyle = q.c;
            ctx.fillRect(-q.s/2, -q.s/2, q.s, q.s*1.6);
            ctx.restore();
          }
          ctx.globalAlpha = 1;
          if(p < 1){
            confettiRAF = requestAnimationFrame(tick);
          } else {
            ctx.clearRect(0,0,w,h);
            confettiCanvas.classList.remove('is-on');
            confettiRAF = null;
          }
        };
        if(confettiRAF) cancelAnimationFrame(confettiRAF);
        confettiRAF = requestAnimationFrame(tick);
      }

      function shouldCelebrate(kind){
        const k = String(kind || '');
        if(celebrateMode === 'off') return false;
        if(celebrateMode === 'complete') return k === 'complete';
        if(celebrateMode === 'complete_skip') return (k === 'complete' || k === 'skip');
        if(celebrateMode === 'complete_skip_missed') return (k === 'complete' || k === 'skip' || k === 'missed');
        return false;
      }
      function maybeCelebrate(kind){
        if(shouldCelebrate(kind)) fireConfetti();
      }

      // ---------- Smooth swaps for active task completion/skip ----------
      let swapInFlight = false;
      function swapIfActive(id, fn, { allowForMissed=false } = {}){
        const isActiveNow = !!(activeTask && activeTask.id === id);
        if(!isActiveNow){ fn(); return; }
        if(prefersReducedMotionV4){ fn(); return; }
        if(swapInFlight) return;
        // avoid animating auto-skip missed unless explicitly allowed
        if(!allowForMissed && id && typeof id === 'string'){
          // no-op here; the caller controls missed
        }
        swapInFlight = true;
        const out = countdownWrapper?.animate([
          { opacity: 1, transform: 'translateY(0px) scale(1)' },
          { opacity: 0, transform: 'translateY(-10px) scale(0.99)' }
        ], { duration: 160, easing: 'cubic-bezier(0.2,0.8,0.2,1)', fill: 'forwards' });
        (out?.finished || Promise.resolve()).then(() => {
          fn();
          countdownWrapper?.animate([
            { opacity: 0, transform: 'translateY(10px) scale(0.99)' },
            { opacity: 1, transform: 'translateY(0px) scale(1)' }
          ], { duration: 260, easing: 'cubic-bezier(0.2,0.8,0.2,1)', fill: 'forwards' });
        }).finally(() => {
          setTimeout(() => { swapInFlight = false; }, 320);
        });
      }

      // ---------- List FLIP animation helpers ----------
      let pendingFlipRects = null;
      let pendingFlashId = null;

      function captureTaskRects(){
        const map = new Map();
        if(!taskListEl) return map;
        taskListEl.querySelectorAll('.task-row[data-id]').forEach(el => {
          map.set(el.getAttribute('data-id'), el.getBoundingClientRect());
        });
        return map;
      }
      function runFlipAnimations(prevMap){
        if(!taskListEl || !prevMap || prefersReducedMotionV4) return;
        const rows = Array.from(taskListEl.querySelectorAll('.task-row[data-id]'));
        for(const el of rows){
          const id = el.getAttribute('data-id');
          const prev = prevMap.get(id);
          const now = el.getBoundingClientRect();
          if(prev){
            const dy = prev.top - now.top;
            if(Math.abs(dy) > 0.5){
              el.animate([
                { transform: 'translateY(' + dy + 'px)' },
                { transform: 'translateY(0px)' }
              ], { duration: 280, easing: 'cubic-bezier(0.2,0.8,0.2,1)' });
            }
          } else {
            el.animate([
              { opacity: 0, transform: 'translateY(10px)' },
              { opacity: 1, transform: 'translateY(0px)' }
            ], { duration: 260, easing: 'cubic-bezier(0.2,0.8,0.2,1)' });
          }
          if(pendingFlashId && id === pendingFlashId){
            el.classList.add('flash');
            setTimeout(() => el.classList.remove('flash'), 820);
            try{
              el.scrollIntoView({ block:'center', behavior: prefersReducedMotionV4 ? 'auto' : 'smooth' });
            }catch(_){}
          }
        }
        pendingFlashId = null;
      }

      // Replace renderTaskList with v4 version (adds edit + runs FLIP)
      const __renderTaskListOld = renderTaskList;
      
      renderTaskList = function(){
        if(!taskListEl) return;

        const prev = pendingFlipRects;
        pendingFlipRects = null;

        const pending = tasks.filter(t => !t.completed && !t.archived).sort(sortByDue);
        const completed = tasks.filter(t => !!t.completed).sort(sortByDue);
        const missed = tasks.filter(t => !!t.archived && !t.completed).sort(sortByDue);

        const pendingCounts = new Map();
        const completedCounts = new Map();
        const missedCounts = new Map();
        for(const t of pending){ const k = String(t.dueTs); pendingCounts.set(k, (pendingCounts.get(k)||0)+1); }
        for(const t of completed){ const k = String(t.dueTs); completedCounts.set(k, (completedCounts.get(k)||0)+1); }
        for(const t of missed){ const k = String(t.dueTs); missedCounts.set(k, (missedCounts.get(k)||0)+1); }

        const blocks = [];

        function row(t, badgeText, section, countsMap){
          const due = formatDueLong(new Date(t.dueTs));
          const isActive = activeTask && t.id === activeTask.id;
          const badge = badgeText ? `<span class="badge">${escapeHtml(badgeText)}</span>` : '';
          const title = escapeHtml((t.title || 'Countdown').trim());
          const isPending = (!t.completed && !t.archived);

          const key = String(t.dueTs);
          const canReorder = !!(countsMap && (countsMap.get(key) || 0) > 1);
          const handle = canReorder ? `<div class="drag-handle" draggable="true" title="Drag to reorder (same due date/time)">⋮⋮</div>` : '';

          return `
            <div class="task-row ${isActive ? 'is-active' : ''}" data-id="${escapeHtml(t.id)}" data-duets="${escapeHtml(String(t.dueTs))}" data-section="${escapeHtml(section||'')}">
              <div class="task-left">
                ${handle}
                <div class="task-main">
                  <div class="task-title">${isActive ? '▶ ' : ''}${title}</div>
                  <div class="task-sub">
                    <span class="badge">Due: ${escapeHtml(due)}</span>
                    ${badge}
                  </div>
                </div>
              </div>
              <div class="task-actions-mini">
                ${isPending ? `
                  <button class="btn mini-btn" data-action="complete" title="Mark completed">✓</button>
                  <button class="btn ghost mini-btn" data-action="edit" title="Edit">✎</button>
                  <button class="btn ghost mini-btn" data-action="delete" title="Delete">🗑</button>
                ` : `
                  <button class="btn ghost mini-btn" data-action="restore" title="Restore">↩</button>
                  <button class="btn ghost mini-btn" data-action="delete" title="Delete">🗑</button>
                `}
              </div>
            </div>`;
        }

        if(!pending.length && !completed.length && !missed.length){
          blocks.push(`<div class="task-row"><div class="task-main"><div class="task-title">No countdowns yet</div><div class="task-sub">Add one above.</div></div></div>`);
        } else {
          if(pending.length){
            blocks.push(`<div class="task-row"><div class="task-main"><div class="task-title">Upcoming</div><div class="task-sub">Only one countdown is shown at a time. The earliest due date is shown on the main screen.</div></div></div>`);
            pending.forEach(t => blocks.push(row(t, (isFinite(t.dueTs) && t.dueTs < Date.now()) ? 'Overdue' : '', 'pending', pendingCounts)));
          }
          if(completed.length){
            blocks.push(`<div class="task-row"><div class="task-main"><div class="task-title">Completed</div><div class="task-sub">Saved on this device.</div></div></div>`);
            completed.forEach(t => blocks.push(row(t, 'Completed', 'completed', completedCounts)));
          }
          if(missed.length){
            blocks.push(`<div class="task-row"><div class="task-main"><div class="task-title">Missed / Skipped</div><div class="task-sub">These are archived so the timer can move on.</div></div></div>`);
            missed.forEach(t => blocks.push(row(t, t.archivedReason || 'Missed', 'missed', missedCounts)));
          }
        }

        taskListEl.innerHTML = blocks.join('');
        runFlipAnimations(prev);
      };
// Improve main buttons: hide undo if no history
      if(typeof updateMainButtons === 'function'){
        const __updateMainButtons = updateMainButtons;
        updateMainButtons = function(){
          const hasActive = !!activeTask;
          if (completeTaskBtn) completeTaskBtn.disabled = !hasActive;
          if (skipTaskBtn) skipTaskBtn.disabled = !hasActive;

          // Catch-up button: visible if there are missed/overdue tasks or catch-up is enabled
          const now = Date.now();
          const hasMissedForCatchUp = tasks.some(t => !t?.completed && Number.isFinite(t?.dueTs) && ((t?.archived && t?.archivedReason === 'missed') || (!t?.archived && t?.dueTs < now)));
          if (catchUpBtn) {
            catchUpBtn.style.display = (catchUpMode || hasMissedForCatchUp) ? '' : 'none';
            catchUpBtn.textContent = catchUpMode ? 'Exit catch-up' : 'Catch-up';
          }

          const hasHistory = tasks.some(t => t.completed || t.archived);
          if (undoLastBtn) {
            undoLastBtn.style.display = hasHistory ? '' : 'none';
            const la = getLastAction();
            const t = la?.id ? tasks.find(x => x.id === la.id) : null;
            const canUndo =
              !!(la && la.id && t &&
                ((la.type === 'complete' && t.completed) || (la.type === 'archive' && t.archived)));
            undoLastBtn.disabled = !canUndo;
          }
        };
      }

      // ---------- Editing modal ----------
      let editingId = null;

      function toDatetimeLocalValue(ts){
        const d = new Date(ts);
        if(!Number.isFinite(d.getTime())) return '';
        const pad = (n) => String(n).padStart(2,'0');
        const yyyy = d.getFullYear();
        const mm = pad(d.getMonth()+1);
        const dd = pad(d.getDate());
        const hh = pad(d.getHours());
        const mi = pad(d.getMinutes());
        return `${yyyy}-${mm}-${dd}T${hh}:${mi}`;
      }

      function openEdit(id){
        const t = tasks.find(x => x.id === id);
        if(!t) return;
        editingId = id;
        if(editTaskNameInput) editTaskNameInput.value = String(t.title || '');
        if(editTaskDateInput) editTaskDateInput.value = toDatetimeLocalValue(t.dueTs);

        if(!editModal || !modalBackdrop) return;
        editModal.hidden = false;
        modalBackdrop.classList.add('show');
        editModal.classList.add('show');
        try{ editTaskNameInput?.focus(); }catch(_){}
      }
      function closeEdit(){
        editingId = null;
        if(!editModal || !modalBackdrop) return;
        editModal.classList.remove('show');
        modalBackdrop.classList.remove('show');
        editModal.hidden = true;
      }

      editCancelBtn?.addEventListener('click', closeEdit);
      modalBackdrop?.addEventListener('click', () => {
        // Close edit modal if it's open (confirm modal handles itself)
        if(editModal && !editModal.hidden && editModal.classList.contains('show')) closeEdit();
      });
      document.addEventListener('keydown', (e) => {
        if(e.key === 'Escape'){
          if(editModal && !editModal.hidden && editModal.classList.contains('show')) closeEdit();
        }
      });

      editSaveBtn?.addEventListener('click', () => {
        const id = editingId;
        if(!id) return;

        const idx = tasks.findIndex(x => x.id === id);
        if(idx < 0) return;

        const newTitle = String(editTaskNameInput?.value || '').trim() || 'Countdown';
        const dueRaw = String(editTaskDateInput?.value || '').trim();
        const d = new Date(dueRaw);
        const dueTs = d.getTime();
        if(!Number.isFinite(dueTs)){
          showToast('That date/time didn’t parse — try again');
          return;
        }

        // capture positions before change
        pendingFlipRects = captureTaskRects();
        pendingFlashId = id;

        const prevDueTs = Number(tasks[idx].dueTs);
        tasks[idx].title = newTitle;
        if(Number.isFinite(prevDueTs) && prevDueTs !== dueTs){
          // Moving into a new due group — default to the end of that group until you reorder.
          tasks[idx].tieOrder = Number.MAX_SAFE_INTEGER;
        }
        tasks[idx].dueTs = dueTs;
        tasks.sort(sortByDue);
        saveTasks(tasks);
        setActiveFromList();
        closeEdit();
      });

      // Double-click title to edit (only for pending tasks)
      taskListEl?.addEventListener('dblclick', (e) => {
        const rowEl = e.target.closest('.task-row[data-id]');
        if(!rowEl) return;
        const id = rowEl.getAttribute('data-id');
        const t = tasks.find(x => x.id === id);
        if(!t || t.completed || t.archived) return;
        openEdit(id);
      });

      // Replace deleteTask with confirmation
      if(typeof deleteTask === 'function'){
        const __deleteTask = deleteTask;
        deleteTask = function(id){
          const t = tasks.find(x => x.id === id);
          const name = t ? String(t.title || 'Countdown') : 'this task';
          confirmAction({
            title: 'Delete task?',
            message: 'This will permanently delete:\n' + name,
            okText: 'Delete',
            cancelText: 'Cancel',
            danger: true
          }).then(ok => {
            if(!ok) return;
            pendingFlipRects = captureTaskRects();
            __deleteTask(id);
          });
        };
      }

      // Make list buttons respect edit action
      taskListEl?.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-action]');
        const rowEl = e.target.closest('.task-row[data-id]');
        if(!btn || !rowEl) return;
        const id = rowEl.getAttribute('data-id');
        const action = btn.getAttribute('data-action');
        if(!id || !action) return;

        if(action === 'edit') openEdit(id);
      }, true);


      // ===== v9: manual reorder for items with identical due date/time (saved) =====
      let dragInfoV9 = null;

      function predicateForSection(section){
        if(section === 'pending') return (t) => !t?.completed && !t?.archived;
        if(section === 'completed') return (t) => !!t?.completed;
        if(section === 'missed') return (t) => !!t?.archived && !t?.completed;
        return () => false;
      }

      function applyManualReorderV9(dueTsStr, section, orderedIds, flashId){
        const dueTs = Number(dueTsStr);
        if(!Number.isFinite(dueTs)) return;

        const pred = predicateForSection(section);

        // Capture current positions for FLIP before re-render
        pendingFlipRects = captureTaskRects();
        pendingFlashId = flashId || null;

        // Build full-group order, then replace only the section subset at their existing slots.
        const group = tasks.filter(t => Number(t?.dueTs) === dueTs).slice().sort(sortByDue);
        if(!group.length) return;

        const idxs = [];
        const byId = new Map();
        for(let i=0;i<group.length;i++){
          const t = group[i];
          if(pred(t)){
            idxs.push(i);
            byId.set(String(t.id), t);
          }
        }
        if(!idxs.length) return;

        const cleaned = (orderedIds || []).map(String).filter(id => byId.has(id));
        if(cleaned.length !== idxs.length) return;

        for(let k=0;k<idxs.length;k++){
          group[idxs[k]] = byId.get(cleaned[k]);
        }
        // Assign sequential tieOrder for the full group
        for(let i=0;i<group.length;i++){
          group[i].tieOrder = i;
        }

        saveTasks(tasks);
        setActiveFromList();
        showToast('Reordered');
      }

      function clearDragOverV9(){
        if(!taskListEl) return;
        taskListEl.querySelectorAll('.task-row.drag-over').forEach(el => el.classList.remove('drag-over'));
      }
      function clearDraggingV9(){
        if(!taskListEl) return;
        taskListEl.querySelectorAll('.task-row.dragging').forEach(el => el.classList.remove('dragging'));
        clearDragOverV9();
      }

      taskListEl?.addEventListener('dragstart', (e) => {
        const handle = e.target?.closest?.('.drag-handle[draggable="true"]');
        if(!handle) return;

        const rowEl = handle.closest('.task-row[data-id]');
        if(!rowEl) return;

        const id = rowEl.getAttribute('data-id');
        const due = rowEl.getAttribute('data-duets');
        const section = rowEl.getAttribute('data-section') || '';
        if(!id || !due || !section) return;

        dragInfoV9 = { id, due, section };
        rowEl.classList.add('dragging');

        try{
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', id);
        }catch(_){}
      });

      taskListEl?.addEventListener('dragend', () => {
        dragInfoV9 = null;
        clearDraggingV9();
      });

      taskListEl?.addEventListener('dragover', (e) => {
        if(!dragInfoV9) return;
        const rowEl = e.target?.closest?.('.task-row[data-id]');
        if(!rowEl) return;

        const due = rowEl.getAttribute('data-duets');
        const section = rowEl.getAttribute('data-section') || '';
        const targetId = rowEl.getAttribute('data-id');

        if(!due || !targetId) return;
        if(due !== dragInfoV9.due) return;
        if(section !== dragInfoV9.section) return;
        if(targetId === dragInfoV9.id) return;

        e.preventDefault();
        clearDragOverV9();
        rowEl.classList.add('drag-over');

        try{ e.dataTransfer.dropEffect = 'move'; }catch(_){}
      });

      taskListEl?.addEventListener('dragleave', (e) => {
        const rowEl = e.target?.closest?.('.task-row[data-id]');
        if(!rowEl) return;
        rowEl.classList.remove('drag-over');
      });

      taskListEl?.addEventListener('drop', (e) => {
        if(!dragInfoV9) return;
        const rowEl = e.target?.closest?.('.task-row[data-id]');
        if(!rowEl) return;

        const targetId = rowEl.getAttribute('data-id');
        const due = rowEl.getAttribute('data-duets');
        const section = rowEl.getAttribute('data-section') || '';
        if(!targetId || !due) return;

        if(due !== dragInfoV9.due || section !== dragInfoV9.section) return;

        e.preventDefault();

        const rect = rowEl.getBoundingClientRect();
        const insertAfter = (e.clientY - rect.top) > (rect.height / 2);

        const groupEls = Array.from(taskListEl.querySelectorAll('.task-row[data-id]'))
          .filter(el => el.getAttribute('data-duets') === due && (el.getAttribute('data-section') || '') === section);

        const ids = groupEls.map(el => el.getAttribute('data-id')).filter(Boolean);
        const fromId = dragInfoV9.id;

        // Reorder only within this same-due, same-section group
        let next = ids.filter(id => id !== fromId);
        const tIndex = next.indexOf(targetId);
        if(tIndex < 0){
          clearDraggingV9();
          dragInfoV9 = null;
          return;
        }
        const insertAt = insertAfter ? (tIndex + 1) : tIndex;
        next.splice(insertAt, 0, fromId);

        applyManualReorderV9(due, section, next, fromId);

        dragInfoV9 = null;
        clearDraggingV9();
      });
      // Wrap markCompleted / archiveTask / restoreTask to add FLIP + celebration + swap
      if(typeof markCompleted === 'function'){
        const __markCompleted = markCompleted;
        markCompleted = function(id){
          pendingFlipRects = captureTaskRects();
          swapIfActive(id, () => {
            __markCompleted(id);
            maybeCelebrate('complete');
          });
        };
      }
      if(typeof archiveTask === 'function'){
        const __archiveTask = archiveTask;
        archiveTask = function(id, reason){
          const kind = (String(reason) === 'missed') ? 'missed' : 'skip';
          pendingFlipRects = captureTaskRects();

          // Skip swap animation for missed auto-skip (keeps it calm), but celebration may still happen if enabled
          if(String(reason) === 'missed'){
            __archiveTask(id, reason);
            maybeCelebrate(kind);
          } else {
            swapIfActive(id, () => {
              __archiveTask(id, reason);
              maybeCelebrate(kind);
            });
          }
        };
      }
      if(typeof restoreTask === 'function'){
        const __restoreTask = restoreTask;
        restoreTask = function(id){
          pendingFlipRects = captureTaskRects();
          __restoreTask(id);
        };
      }

      // Re-bind importTasks so replace confirmation uses the themed modal
      if(importTasksBtn){
        try{ importTasksBtn.removeEventListener('click', importTasks); }catch(_){}
        const __parseImport = parseImportTextToTasks;
        importTasks = async function(){
          const text = importExportText?.value || '';
          const replace = !!replaceOnImport?.checked;
          const skipDupes = (skipDupesOnImport?.checked ?? true);

          const parsed = __parseImport(text);
          const incoming = parsed.tasks || [];

          if(parsed.errors && parsed.errors.length){
            showToast(parsed.errors[0]);
          }
          if(!incoming.length){
            showToast('Nothing to import.');
            return;
          }

          if(replace){
            const ok = await confirmAction({
              title: 'Replace tasks?',
              message: 'This will replace your existing countdown tasks with the imported list.',
              okText: 'Replace',
              cancelText: 'Cancel',
              danger: true
            });
            if(!ok) return;
            tasks = [];
            lastCreatedAt = 0;
            try{ localStorage.removeItem(STORAGE.lastAction); }catch(e){}
          }

          const existingKey = new Set();
          if(skipDupes){
            for(const t of tasks){
              const k = String(Number(t?.dueTs) || 0) + '::' + String(t?.title || '').trim();
              existingKey.add(k);
            }
          }

          let added = 0;
          let skipped = 0;
          const addedIds = [];
          for(const t of incoming){
            const title = String(t.title || '').trim() || 'Countdown';
            const dueTs = Number(t.dueTs);
            if(!Number.isFinite(dueTs)) continue;
            const key = String(dueTs) + '::' + title;
            if(skipDupes && existingKey.has(key)){
              skipped += 1;
              continue;
            }
            if(skipDupes) existingKey.add(key);

            const createdAt = nextCreatedAt(Number.isFinite(t.createdAt) ? Number(t.createdAt) : undefined);
            const id = String(t.id || ('t_' + createdAt + '_' + Math.random().toString(36).slice(2,7)));

            tasks.push({
              id,
              title,
              dueTs,
              createdAt,
              completed: !!t.completed,
              completedAt: (t.completedAt !== undefined ? t.completedAt : null),
              archived: !!t.archived,
              archivedAt: (t.archivedAt !== undefined ? t.archivedAt : null),
              archivedReason: (t.archivedReason !== undefined ? t.archivedReason : null)
            });

            added += 1;
            addedIds.push(id);
          }

          // FLIP animation baseline
          pendingFlipRects = captureTaskRects();

          tasks.sort(sortByDue);
          saveTasks(tasks);

          setActiveFromList();
          updateTitleAndStatus();
          updateCountdown();
          updateMainButtons();

          // keep v3 import animations (new rows + active highlight)
          if(!prefersReducedMotion){
            try{
              countdownWrapper?.classList.remove('import-flash');
              void countdownWrapper?.offsetWidth;
              countdownWrapper?.classList.add('import-flash');
              setTimeout(() => countdownWrapper?.classList.remove('import-flash'), 720);
            }catch(_){}
          }

          try{
            if(taskListEl && addedIds.length){
              const esc = (s) => (window.CSS && CSS.escape) ? CSS.escape(String(s)) : String(s).replace(/"/g,'\\\"');
              for(const id of addedIds.slice(0, 200)){
                const el = taskListEl.querySelector('.task-row[data-id="' + esc(id) + '"]');
                if(el){
                  el.classList.remove('just-added');
                  void el.offsetWidth;
                  el.classList.add('just-added');
                  setTimeout(() => el.classList.remove('just-added'), 650);
                }
              }
              const activeRow = taskListEl.querySelector('.task-row.is-active');
              if(activeRow){
                activeRow.classList.add('import-highlight');
                activeRow.scrollIntoView({ block: 'center', behavior: prefersReducedMotion ? 'auto' : 'smooth' });
                setTimeout(() => activeRow.classList.remove('import-highlight'), 1500);
              }
            }
          }catch(_){}

          showToast('Imported ' + added + (skipped ? (' • skipped ' + skipped + ' duplicate' + (skipped===1?'':'s')) : '') + '.');
        };
        importTasksBtn.addEventListener('click', () => { importTasks(); });
      }

      // Initialize main display from saved tasks
      setActiveFromList();
      updateTitleAndStatus();
      updateMainButtons();

      // --- Smooth effect "spring" animation (so slider changes feel buttery) ---
      const prefersReducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      const effectCurrent = {
        contrast: Number(contrastSlider.value),
        bloom: Number(bloomSlider.value),
        bloomOpacity: Number(bloomOpacitySlider.value),
        blur: Number(blurSlider.value),
      };
      const effectTarget = { ...effectCurrent };

      function applyEffectVars(state) {
        document.documentElement.style.setProperty('--contrast', String(state.contrast));
        document.documentElement.style.setProperty('--bloom', String(state.bloom));
        document.documentElement.style.setProperty('--bloomOpacity', String(state.bloomOpacity));
        const eff = (state.bloom > 0.001) ? state.bloomOpacity : 0;
        document.documentElement.style.setProperty('--bloomOpacityEff', String(eff));
        document.documentElement.style.setProperty('--blur', String(state.blur));
      }

      applyEffectVars(effectCurrent);

      function tickEffects() {
        // When reduced-motion is on, just snap to target
        if (prefersReducedMotion) {
          applyEffectVars(effectTarget);
          return;
        }

        const speed = 0.18; // higher = snappier, lower = floatier
        effectCurrent.contrast += (effectTarget.contrast - effectCurrent.contrast) * speed;
        effectCurrent.bloom += (effectTarget.bloom - effectCurrent.bloom) * speed;
        effectCurrent.bloomOpacity += (effectTarget.bloomOpacity - effectCurrent.bloomOpacity) * speed;
        effectCurrent.blur += (effectTarget.blur - effectCurrent.blur) * speed;

        applyEffectVars(effectCurrent);
        requestAnimationFrame(tickEffects);
      }

      if (!prefersReducedMotion) requestAnimationFrame(tickEffects);

      function setEffectTargetsFromInputs() {
        effectTarget.contrast = Number(contrastSlider.value);
        effectTarget.bloom = Number(bloomSlider.value);
        effectTarget.bloomOpacity = Number(bloomOpacitySlider.value);
        effectTarget.blur = Number(blurSlider.value);

        if (prefersReducedMotion) applyEffectVars(effectTarget);
      }

      // Sync sliders and inputs
      function syncSliderWithInput(slider, input) {
        const clamp = () => {
          let v = input.value;
          if (v === '' || v === null) return;
          const num = Number(v);
          const min = Number(input.min);
          const max = Number(input.max);
          const clamped = Math.min(max, Math.max(min, num));
          input.value = clamped;
          slider.value = clamped;
        };

        slider.addEventListener('input', () => {
          input.value = slider.value;
          setRangeFill(slider);
          setEffectTargetsFromInputs();
          if(currentPresetId) setActivePreset(null);
          syncRestoreDefaultsVisibility();
        });

        input.addEventListener('input', () => {
          clamp();
          setRangeFill(slider);
          setEffectTargetsFromInputs();
          if(currentPresetId) setActivePreset(null);
          syncRestoreDefaultsVisibility();
        });
      }

      function setRangeFill(rangeEl){
        if (!rangeEl) return;
        const min = Number(rangeEl.min ?? 0);
        const max = Number(rangeEl.max ?? 100);
        const val = Number(rangeEl.value ?? 0);
        const denom = (max - min) || 1;
        const p = ((val - min) / denom) * 100;
        rangeEl.style.setProperty('--p', String(Math.max(0, Math.min(100, p))));
      }

      // Initialize range fills
      [contrastSlider, bloomSlider, bloomOpacitySlider, blurSlider].forEach(setRangeFill);

      syncSliderWithInput(contrastSlider, contrastInput);
      syncSliderWithInput(bloomSlider, bloomInput);
      syncSliderWithInput(bloomOpacitySlider, bloomOpacityInput);
      syncSliderWithInput(blurSlider, blurInput);

      // Presets + reset
      function setEffects(contrast, bloom, bloomOpacity, blur) {
        contrastSlider.value = String(contrast);
        contrastInput.value = String(contrast);
        bloomSlider.value = String(bloom);
        bloomInput.value = String(bloom);
        bloomOpacitySlider.value = String(bloomOpacity);
        bloomOpacityInput.value = String(bloomOpacity);
        blurSlider.value = String(blur);
        blurInput.value = String(blur);
        [contrastSlider, bloomSlider, bloomOpacitySlider, blurSlider].forEach(setRangeFill);
        setEffectTargetsFromInputs();
      }

      presetCrispButton?.addEventListener('click', () => { setEffects(115, 0, 1, 0); setActivePreset('crisp'); syncRestoreDefaultsVisibility(); });
      presetSoftButton?.addEventListener('click', () => { setEffects(105, 10, 0.65, 8); setActivePreset('soft'); syncRestoreDefaultsVisibility(); });
      presetNeonButton?.addEventListener('click', () => { setEffects(145, 24, 0.85, 6); setActivePreset('neon'); syncRestoreDefaultsVisibility(); });

      function resetAllSettings() {
        showDays = true; showHours = true; showMinutes = true; showSeconds = true;
        forceShowZero.days = false; forceShowZero.hours = false; forceShowZero.minutes = false; forceShowZero.seconds = false;
        // Unit button labels are derived from actual visibility each tick

        // Title visible
        toggleTitleButton.dataset.active = 'true';
        toggleTitleButton.textContent = 'Hide Title';
        titleElement.classList.remove('hidden');
        countdownWrapper.classList.remove('centered');

        setFontWeight('400');

        // Unit labels on
        showUnitLabels = true;
        toggleUnitLabelsButton && (toggleUnitLabelsButton.dataset.active = 'true');
        toggleUnitLabelsButton && (toggleUnitLabelsButton.textContent = 'Hide Unit Labels');

        // Formats
        useCondensedWindowFormat = false;
        useCondensedCountdownFormat = false;
        toggleCondensedWindowButton.textContent = 'Condense Window Title';
        toggleCondensedCountdownButton.textContent = 'Condense Countdown';

        // Effects
        setEffects(100, 0, 1, 0);

        // Font
        selectedFont = 'inter';
        syncOptionDropdown(fontMenu, fontBtn, selectedFont, FONT_LABELS);
        document.documentElement.style.setProperty('--font-main', FONT_OPTIONS[selectedFont]);
        localStorage.setItem('cb_font', selectedFont);

        // Bloom border on (clipped) by default
        bloomBorderOn = true;
        applyBloomBorderState();

        // Extra toggles + preset state
        showStatusLine = true;
        showTaskActions = true;
        includeTaskNameInWindowTitle = true;
        setActivePreset(null);
        applyExtraVisibility();
        syncExtraToggleButtons();

        updateCountdown();
        syncRestoreDefaultsVisibility();
      }

      // ===== Startup UI settings (manual save) =====
      const UI_STARTUP_KEY = 'cb_ui_startup_v1';

      const DEFAULT_UI_SETTINGS = {
        showDays: true,
        showHours: true,
        showMinutes: true,
        showSeconds: true,
        showTitle: true,
        fontWeight: "400",
        showUnitLabels: true,
        condensedWindow: false,
        condensedCountdown: false,
        contrast: 100,
        bloom: 0,
        bloomOpacity: 1,
        blur: 0,
        font: 'inter',
        bloomBorderOn: true,
        showStatusLine: true,
        showTaskActions: true,
        includeTaskNameInWindowTitle: true,
        celebrateMode: 'off',
        bgMode: 'file',
        bgFilePath: './Images/Photography/Forests/2.jpg',
        bgUnsplashQuery: 'forest',
        bgUnsplashFeaturedOnly: false,
        bgUnsplashAccessKey: '',
        bgUnsplashRefreshMode: 'newtab',
        bgUnsplashRefreshMinutes: 30,
        presetId: null
      };

      function safeParseJSON(raw){
        try{ return JSON.parse(raw); }catch(e){ return null; }
      }

      function getCurrentUISnapshot(){
        return {
          showDays, showHours, showMinutes, showSeconds,
          showTitle: !titleElement.classList.contains('hidden'),
          fontWeight: String(countdownElement?.style?.fontWeight || '400'),
          showUnitLabels,
          condensedWindow: useCondensedWindowFormat,
          condensedCountdown: useCondensedCountdownFormat,
          contrast: Number(contrastSlider?.value ?? 100),
          bloom: Number(bloomSlider?.value ?? 0),
          bloomOpacity: Number(bloomOpacitySlider?.value ?? 1),
          blur: Number(blurSlider?.value ?? 0),
          font: selectedFont,
          bloomBorderOn,
          showStatusLine,
          showTaskActions,
          includeTaskNameInWindowTitle,
          presetId: currentPresetId
        };
      }

      function normalizeUISnapshot(s){
        const out = { ...DEFAULT_UI_SETTINGS, ...(s || {}) };

        // Coerce types
        out.showDays = !!out.showDays;
        out.showHours = !!out.showHours;
        out.showMinutes = !!out.showMinutes;
        out.showSeconds = !!out.showSeconds;

        out.showTitle = !!out.showTitle;
        out.fontWeight = ["200","400","600","700"].includes(String(out.fontWeight)) ? String(out.fontWeight) : "400";
        out.showUnitLabels = !!out.showUnitLabels;

        out.condensedWindow = !!out.condensedWindow;
        out.condensedCountdown = !!out.condensedCountdown;

        out.contrast = Number(out.contrast);
        out.bloom = Number(out.bloom);
        out.bloomOpacity = Number(out.bloomOpacity);
        out.blur = Number(out.blur);

        out.font = (out.font && FONT_OPTIONS[out.font]) ? out.font : DEFAULT_UI_SETTINGS.font;
        out.bloomBorderOn = !!out.bloomBorderOn;

        out.showStatusLine = !!out.showStatusLine;
        out.showTaskActions = !!out.showTaskActions;
        out.includeTaskNameInWindowTitle = !!out.includeTaskNameInWindowTitle;


        // Celebration mode
        const __celebrateAllowed = new Set(['off','complete','complete_skip','complete_skip_missed']);
        out.celebrateMode = __celebrateAllowed.has(String(out.celebrateMode || 'off')) ? String(out.celebrateMode) : 'off';

        // Background settings
        const __bgAllowed = new Set(['default','file','unsplash']);
        out.bgMode = __bgAllowed.has(String(out.bgMode || DEFAULT_UI_SETTINGS.bgMode)) ? String(out.bgMode) : DEFAULT_UI_SETTINGS.bgMode;
        out.bgFilePath = String(out.bgFilePath || DEFAULT_UI_SETTINGS.bgFilePath);
        out.bgUnsplashQuery = String(out.bgUnsplashQuery || DEFAULT_UI_SETTINGS.bgUnsplashQuery);
        out.bgUnsplashFeaturedOnly = !!out.bgUnsplashFeaturedOnly;
        out.bgUnsplashAccessKey = String(out.bgUnsplashAccessKey || DEFAULT_UI_SETTINGS.bgUnsplashAccessKey || '');

        const __rm = String(out.bgUnsplashRefreshMode || DEFAULT_UI_SETTINGS.bgUnsplashRefreshMode || 'newtab');
        out.bgUnsplashRefreshMode = (['newtab','minutes','hour','day','week'].includes(__rm)) ? __rm : DEFAULT_UI_SETTINGS.bgUnsplashRefreshMode;

        out.bgUnsplashRefreshMinutes = parseInt(out.bgUnsplashRefreshMinutes, 10);
        if(!Number.isFinite(out.bgUnsplashRefreshMinutes) || out.bgUnsplashRefreshMinutes < 1) out.bgUnsplashRefreshMinutes = DEFAULT_UI_SETTINGS.bgUnsplashRefreshMinutes;
        if(out.bgUnsplashRefreshMinutes > 1440) out.bgUnsplashRefreshMinutes = 1440;

        out.presetId = (out.presetId === 'crisp' || out.presetId === 'soft' || out.presetId === 'neon') ? out.presetId : null;

        // NaN fallbacks
        if (!Number.isFinite(out.contrast)) out.contrast = DEFAULT_UI_SETTINGS.contrast;
        if (!Number.isFinite(out.bloom)) out.bloom = DEFAULT_UI_SETTINGS.bloom;
        if (!Number.isFinite(out.bloomOpacity)) out.bloomOpacity = DEFAULT_UI_SETTINGS.bloomOpacity;
        if (!Number.isFinite(out.blur)) out.blur = DEFAULT_UI_SETTINGS.blur;

        return out;
      }

      function uiSnapshotsEqual(a,b){
        const x = normalizeUISnapshot(a);
        const y = normalizeUISnapshot(b);
        const keys = Object.keys(DEFAULT_UI_SETTINGS);
        for(const k of keys){
          const xv = x[k];
          const yv = y[k];
          if(typeof xv === 'number' || typeof yv === 'number'){
            if(Math.abs(Number(xv) - Number(yv)) > 1e-9) return false;
          } else {
            if((xv ?? null) !== (yv ?? null)) return false;
          }
        }
        return true;
      }

      function syncRestoreDefaultsVisibility(){
        if(!resetSettingsButton) return;
        const differs = !uiSnapshotsEqual(getCurrentUISnapshot(), DEFAULT_UI_SETTINGS);
        resetSettingsButton.style.display = differs ? 'inline-flex' : 'none';
      }

      function setTitleVisibility(show){
        const on = !!show;
        titleElement.classList.toggle('hidden', !on);
        countdownWrapper.classList.toggle('centered', !on);
        if(toggleTitleButton){
          toggleTitleButton.dataset.active = String(on);
          toggleTitleButton.textContent = on ? 'Hide Title' : 'Show Title';
        }
      }

      function setFontWeight(weight){
        const w = String(weight || '400');
        countdownElement.style.fontWeight = w;
        syncOptionDropdown(fontWeightMenu, fontWeightBtn, w, FONT_WEIGHT_LABELS);
      }

      function setUnitLabels(on){
        showUnitLabels = !!on;
        if(toggleUnitLabelsButton){
          toggleUnitLabelsButton.dataset.active = String(showUnitLabels);
          toggleUnitLabelsButton.textContent = showUnitLabels ? 'Hide Unit Labels' : 'Show Unit Labels';
        }
      }

      function setCondensedWindow(on){
        useCondensedWindowFormat = !!on;
        if(toggleCondensedWindowButton){
          toggleCondensedWindowButton.dataset.active = String(useCondensedWindowFormat);
          toggleCondensedWindowButton.textContent = useCondensedWindowFormat ? 'Use Full Window Title' : 'Condense Window Title';
        }
      }

      function setCondensedCountdown(on){
        useCondensedCountdownFormat = !!on;
        if(toggleCondensedCountdownButton){
          toggleCondensedCountdownButton.dataset.active = String(useCondensedCountdownFormat);
          toggleCondensedCountdownButton.textContent = useCondensedCountdownFormat ? 'Use Full Countdown Format' : 'Condense Countdown Format';
        }
      }

      function applyUISnapshot(rawSnap, opts = {}){
        const snap = normalizeUISnapshot(rawSnap);

        showDays = snap.showDays;
        showHours = snap.showHours;
        showMinutes = snap.showMinutes;
        showSeconds = snap.showSeconds;

        setTitleVisibility(snap.showTitle);
        setFontWeight(snap.fontWeight || "400");
        setUnitLabels(snap.showUnitLabels);
        setCondensedWindow(snap.condensedWindow);
        setCondensedCountdown(snap.condensedCountdown);

        showStatusLine = snap.showStatusLine;
        showTaskActions = snap.showTaskActions;
        includeTaskNameInWindowTitle = snap.includeTaskNameInWindowTitle;
        applyExtraVisibility();
        syncExtraToggleButtons();

        setEffects(snap.contrast, snap.bloom, snap.bloomOpacity, snap.blur);
        setActivePreset(snap.presetId);

        if(snap.font && FONT_OPTIONS[snap.font]){
          selectedFont = snap.font;
          syncOptionDropdown(fontMenu, fontBtn, selectedFont, FONT_LABELS);
          document.documentElement.style.setProperty('--font-main', FONT_OPTIONS[selectedFont]);
          localStorage.setItem('cb_font', selectedFont);
        }

        bloomBorderOn = !!snap.bloomBorderOn;
        applyBloomBorderState();

        if(opts.update !== false){
          updateCountdown();
        }
        syncRestoreDefaultsVisibility();
      }

      function applyStartupSettingsIfAny(){
        const saved = safeParseJSON(localStorage.getItem(UI_STARTUP_KEY));
        if(saved){
          applyUISnapshot(saved, { update: false });
        } else {
          // Ensure defaults UI reflects initial state
          applyExtraVisibility();
          syncExtraToggleButtons();
          syncRestoreDefaultsVisibility();
        }
      }

      function saveStartupSettings(){
        const snap = getCurrentUISnapshot();
        localStorage.setItem(UI_STARTUP_KEY, JSON.stringify(snap));
        showToast('Saved! Your preferences will load next time.');
        syncRestoreDefaultsVisibility();
      }

      function restoreDefaults(){
        localStorage.removeItem(UI_STARTUP_KEY);
        setActivePreset(null);
        resetAllSettings();
        showToast('Restored defaults.');
        syncRestoreDefaultsVisibility();
      }

      saveStartupSettingsButton?.addEventListener('click', saveStartupSettings);
      resetSettingsButton?.addEventListener('click', restoreDefaults);


      // --- Smooth countdown text transitions ---
      let lastCountdownText = '';

      function animateTextSwap(el, nextText) {
        if (nextText === lastCountdownText) return;

        if (prefersReducedMotion) {
          el.textContent = nextText;
          lastCountdownText = nextText;
          return;
        }

        // Cancel any in-flight animations on this element
        try { el.getAnimations().forEach(a => a.cancel()); } catch (e) {}

        // Animate out
        const out = el.animate(
          [
            { opacity: 1, transform: 'translate3d(0,0,0) scale(1)', filter: 'blur(0px)' },
            { opacity: 0, transform: 'translate3d(0,-8px,0) scale(0.985)', filter: 'blur(1.25px)' }
          ],
          { duration: 180, easing: 'cubic-bezier(0.2, 0.8, 0.2, 1)', fill: 'forwards' }
        );

        out.onfinish = () => {
          el.textContent = nextText;
          // Animate in
          el.animate(
            [
              { opacity: 0, transform: 'translate3d(0,10px,0) scale(0.985)', filter: 'blur(1.25px)' },
              { opacity: 1, transform: 'translate3d(0,0,0) scale(1)', filter: 'blur(0px)' }
            ],
            { duration: 260, easing: 'cubic-bezier(0.2, 0.8, 0.2, 1)', fill: 'forwards' }
          );
        };

        lastCountdownText = nextText;
      }

      // Countdown update (aligned to actual second boundary, less drift)
      let timeoutId = null;

      function computeCountdownText() {
        const now = new Date();
        const difference = targetDate - now;

        if (!activeTask || !targetDate) {
          return { displayText: 'Add a countdown in Settings', done: true, doneType: 'empty', days: 0, hours: 0, minutes: 0, seconds: 0 };
        }

        if (difference <= 0) {
          return { displayText: 'Due now', done: true, doneType: 'reached', days: 0, hours: 0, minutes: 0, seconds: 0 };
        }

        let totalSeconds = Math.floor(difference / 1000);
        let days = Math.floor(totalSeconds / (60 * 60 * 24));
        totalSeconds %= 60 * 60 * 24;
        let hours = Math.floor(totalSeconds / (60 * 60));
        totalSeconds %= 60 * 60;
        let minutes = Math.floor(totalSeconds / 60);
        let seconds = totalSeconds % 60;

        if (!showDays) { hours += days * 24; days = 0; }
        if (!showHours) { minutes += hours * 60; hours = 0; }
        if (!showMinutes) { seconds += minutes * 60; minutes = 0; }
        if (!showSeconds) {
          if (seconds > 0) minutes += 1;
          seconds = 0;
        }

        let displayText = '';
        if (useCondensedCountdownFormat) {
          const dispD = showDays && (days > 0 || forceShowZero.days);
          const dispH = showHours && (hours > 0 || forceShowZero.hours || dispD);
          const dispM = showMinutes && (minutes > 0 || forceShowZero.minutes || dispH || dispD);
          const dispS = showSeconds;

          const parts = [];
          if (dispD) parts.push(String(days));
          if (dispH) parts.push(pad2(hours));
          if (dispM) parts.push(pad2(minutes));
          if (dispS) parts.push(pad2(seconds));
          displayText = parts.join(':');
        } else {
          if (showDays && (days > 0 || forceShowZero.days)) displayText += `${days} ${days === 1 ? 'day' : 'days'} `;
          if (showHours && (hours > 0 || forceShowZero.hours)) displayText += `${hours} ${hours === 1 ? 'hour' : 'hours'} `;
          if (showMinutes && (minutes > 0 || forceShowZero.minutes)) displayText += `${minutes} ${minutes === 1 ? 'minute' : 'minutes'} `;
          if (showSeconds) displayText += `${seconds} ${seconds === 1 ? 'second' : 'seconds'}`;
        }

        return { displayText: displayText.trim(), done: false, days, hours, minutes, seconds };
      }

      function updateCountdown() {
        if (timeoutId) { clearTimeout(timeoutId); timeoutId = null; }
        const result = computeCountdownText();

        // Apply display mode class for styling
        countdownElement.classList.toggle('condensed', useCondensedCountdownFormat);
        countdownElement.classList.toggle('verbose', !useCondensedCountdownFormat);

        const labelsOff = useCondensedCountdownFormat || !showUnitLabels;
        countdownElement.classList.toggle('labels-off', labelsOff);
        countdownElement.classList.toggle('labels-on', !labelsOff);

        // If we're done, show final message without per-second animation

        if (result.done) {
          // Keep the structured DOM intact (don’t overwrite countdownElement.textContent).
          // If there’s no active task, just show a friendly message.
          if (result.doneType === 'empty') {
            // Hide units and show a message in the status line/title.
            setUnitVisible(cdDaysUnit, false);
            setUnitVisible(cdHoursUnit, false);
            setUnitVisible(cdMinutesUnit, false);
            setUnitVisible(cdSecondsUnit, false);
            setSepVisible(sepDH, false);
            setSepVisible(sepHM, false);
            setSepVisible(sepMS, false);

            if (statusLine) statusLine.innerHTML = `<span class="pill">No countdowns — add one in Settings</span>`;
            document.title = 'Countdown';
          } else if (result.doneType === 'reached') {
            // Countdown reached zero
            if (activeTask && autoSkipMissed && !catchUpMode) {
              // Archive it so we can move on
              archiveTask(activeTask.id, 'missed');
              // archiveTask() calls setActiveFromList(), which updates targetDate & UI.
              // Re-run immediately so the next task appears without waiting a full second.
              updateCountdown();
              return;
            }

            // Show "Due now" and keep the task visible until the user completes/skips it.
            if (statusLine) statusLine.innerHTML = `<span class="pill">⏰ Due now — mark completed or skip</span>`;
            // Set values to 0
            if (cdDays) cdDays.textContent = '0';
            if (cdHours) cdHours.textContent = '00';
            if (cdMinutes) cdMinutes.textContent = '00';
            if (cdSeconds) cdSeconds.textContent = '00';

            // Make sure at least seconds are visible so the layout doesn’t collapse
            setUnitVisible(cdSecondsUnit, true);
          }

          updateUnitToggleButtons();
          updateMainButtons();

          // align to next second boundary
          const msToNextSecond = 1000 - (Date.now() % 1000);
          timeoutId = setTimeout(updateCountdown, msToNextSecond);
          return;
        }


        // Decide which units are visible.
        // There are 3 situations:
        // 1) user forced-hide (showX === false) => never show
        // 2) normal behavior (showX === true) => show when >0 (plus seconds), auto-hide leading zeros
        // 3) user explicitly toggled ON while value is 0 => forceShowZero[unit] === true => show as "0 unit"
        let showD = false, showH = false, showM = false, showS = false;

        if (useCondensedCountdownFormat) {
          showD = showDays && (result.days > 0 || forceShowZero.days);
          showH = showHours && (result.hours > 0 || forceShowZero.hours || showD);
          showM = showMinutes && (result.minutes > 0 || forceShowZero.minutes || showH || showD);
          showS = showSeconds; // seconds are the "always show" unit in condensed format
        } else {
          showD = showDays && (result.days > 0 || forceShowZero.days);
          showH = showHours && (result.hours > 0 || forceShowZero.hours);
          showM = showMinutes && (result.minutes > 0 || forceShowZero.minutes);
          showS = showSeconds;
        }

        visibleNow = { days: showD, hours: showH, minutes: showM, seconds: showS };

        setUnitVisible(cdDaysUnit, showD);
        setUnitVisible(cdHoursUnit, showH);
        setUnitVisible(cdMinutesUnit, showM);
        setUnitVisible(cdSecondsUnit, showS);

        updateUnitToggleButtons();

        // Condensed separators: show only between visible neighboring units
        if (useCondensedCountdownFormat) {
          setSepVisible(sepDH, showD && showH);
          setSepVisible(sepHM, showH && showM);
          setSepVisible(sepMS, showM && showS);
        } else {
          setSepVisible(sepDH, false);
          setSepVisible(sepHM, false);
          setSepVisible(sepMS, false);
        }

        // Update values (only animate seconds)
        const dText = String(result.days);
        const hText = useCondensedCountdownFormat ? pad2(result.hours) : String(result.hours);
        const mText = useCondensedCountdownFormat ? pad2(result.minutes) : String(result.minutes);
        const sText = useCondensedCountdownFormat ? pad2(result.seconds) : String(result.seconds);

        if (showD) {
          if (dText !== cdDays.textContent) cdDays.textContent = dText;
          cdDaysLabel.textContent = pluralize('day', result.days);
        }
        if (showH) {
          if (hText !== cdHours.textContent) cdHours.textContent = hText;
          cdHoursLabel.textContent = pluralize('hour', result.hours);
        }
        if (showM) {
          if (mText !== cdMinutes.textContent) cdMinutes.textContent = mText;
          cdMinutesLabel.textContent = pluralize('minute', result.minutes);
        }
        if (showS) {
          // Animate seconds only if they changed
          if (sText !== cdSeconds.textContent) {
            animateSecondsSwap(sText);
          }
          cdSecondsLabel.textContent = pluralize('second', result.seconds);
        }

        lastParts = { days: result.days, hours: result.hours, minutes: result.minutes, seconds: result.seconds, condensed: useCondensedCountdownFormat, done: result.done };
        if (useCondensedWindowFormat) {
          const titleParts = [];
          if (showD) titleParts.push(String(result.days));
          if (showH) titleParts.push(String(result.hours));
          if (showM) titleParts.push(String(result.minutes));
          if (showS) titleParts.push(String(result.seconds));
          const timeText = (titleParts.join(':') || result.displayText);
          if (activeTask) {
            if (includeTaskNameInWindowTitle) {
              document.title = (activeTask.title || 'Countdown') + ' • ' + timeText;
            } else {
              document.title = timeText;
            }
          } else {
            document.title = 'Countdown';
          }
        } else {
          const timeText = result.displayText;
          if (activeTask) {
            if (includeTaskNameInWindowTitle) {
              document.title = (activeTask.title || 'Countdown') + ' • ' + timeText;
            } else {
              document.title = timeText;
            }
          } else {
            document.title = 'Countdown';
          }
        }

        // align to next second boundary for smoother/consistent ticks
        const msToNextSecond = 1000 - (Date.now() % 1000);
        timeoutId = setTimeout(updateCountdown, msToNextSecond);
      }

      applyStartupSettingsIfAny();
      updateCountdown();

      function setButtonLabel(button, isVisible, label) {
        if (!button) return;
        button.textContent = (isVisible ? 'Hide ' : 'Show ') + label;
        button.dataset.active = String(!!isVisible);
      }

      function updateUnitToggleButtons(){
        setButtonLabel(toggleDaysButton, visibleNow.days, 'Days');
        setButtonLabel(toggleHoursButton, visibleNow.hours, 'Hours');
        setButtonLabel(toggleMinutesButton, visibleNow.minutes, 'Minutes');
        setButtonLabel(toggleSecondsButton, visibleNow.seconds, 'Seconds');
      }

      function toggleUnit(unit) {
        const currentlyVisible = !!visibleNow[unit];

        const lastVal = Number((lastParts && lastParts[unit] != null) ? lastParts[unit] : 0);

        if (unit === 'days') {
          if (currentlyVisible) { showDays = false; forceShowZero.days = false; }
          else { showDays = true; forceShowZero.days = (lastVal === 0); }
        }
        if (unit === 'hours') {
          if (currentlyVisible) { showHours = false; forceShowZero.hours = false; }
          else { showHours = true; forceShowZero.hours = (lastVal === 0); }
        }
        if (unit === 'minutes') {
          if (currentlyVisible) { showMinutes = false; forceShowZero.minutes = false; }
          else { showMinutes = true; forceShowZero.minutes = (lastVal === 0); }
        }
        if (unit === 'seconds') {
          if (currentlyVisible) { showSeconds = false; forceShowZero.seconds = false; }
          else { showSeconds = true; forceShowZero.seconds = (lastVal === 0); }
        }

        updateCountdown();
        syncRestoreDefaultsVisibility();
      }

      toggleDaysButton?.addEventListener('click', () => toggleUnit('days'));
      toggleHoursButton?.addEventListener('click', () => toggleUnit('hours'));
      toggleMinutesButton?.addEventListener('click', () => toggleUnit('minutes'));
      toggleSecondsButton?.addEventListener('click', () => toggleUnit('seconds'));

      // Title visibility toggle (animated via CSS class)
      toggleTitleButton?.addEventListener('click', () => {
        const isActive = toggleTitleButton.dataset.active === 'true';
        toggleTitleButton.textContent = isActive ? 'Show Title' : 'Hide Title';
        toggleTitleButton.dataset.active = String(!isActive);

        titleElement.classList.toggle('hidden', isActive);
        countdownWrapper.classList.toggle('centered', isActive);
        syncRestoreDefaultsVisibility();
      });

      toggleStatusLineButton?.addEventListener('click', () => {
        showStatusLine = !showStatusLine;
        applyExtraVisibility();
        syncExtraToggleButtons();
        syncRestoreDefaultsVisibility();
      });

      toggleActionButtonsButton?.addEventListener('click', () => {
        showTaskActions = !showTaskActions;
        applyExtraVisibility();
        syncExtraToggleButtons();
        syncRestoreDefaultsVisibility();
      });

      toggleWindowTaskNameButton?.addEventListener('click', () => {
        includeTaskNameInWindowTitle = !includeTaskNameInWindowTitle;
        syncExtraToggleButtons();
        updateCountdown();
        syncRestoreDefaultsVisibility();
      });


      // Font controls (glass dropdowns)
      fontWeightBtn?.addEventListener('click', (e)=>{
        e.preventDefault();
        if(fontWeightDropdown?.classList.contains('open')) closeDropdown(fontWeightDropdown, fontWeightBtn);
        else {
          closeDropdown(fontDropdown, fontBtn);
          openDropdown(fontWeightDropdown, fontWeightBtn);
        }
      });
      fontWeightMenu?.addEventListener('click', (e)=>{
        const item = e.target.closest('.dropdown-item[data-value]');
        if(!item) return;
        const value = String(item.getAttribute('data-value') || '400');
        setFontWeight(value);
        closeDropdown(fontWeightDropdown, fontWeightBtn);
        updateCountdown();
        syncRestoreDefaultsVisibility();
      });
      fontBtn?.addEventListener('click', (e)=>{
        e.preventDefault();
        if(fontDropdown?.classList.contains('open')) closeDropdown(fontDropdown, fontBtn);
        else {
          closeDropdown(fontWeightDropdown, fontWeightBtn);
          openDropdown(fontDropdown, fontBtn);
        }
      });
      fontMenu?.addEventListener('click', (e)=>{
        const item = e.target.closest('.dropdown-item[data-value]');
        if(!item) return;
        const key = String(item.getAttribute('data-value') || 'inter');
        selectedFont = FONT_OPTIONS[key] ? key : 'inter';
        document.documentElement.style.setProperty('--font-main', FONT_OPTIONS[selectedFont]);
        localStorage.setItem('cb_font', selectedFont);
        syncOptionDropdown(fontMenu, fontBtn, selectedFont, FONT_LABELS);
        closeDropdown(fontDropdown, fontBtn);
        syncRestoreDefaultsVisibility();
      });
      document.addEventListener('click', (e)=>{
        if(fontDropdown && !fontDropdown.contains(e.target)) closeDropdown(fontDropdown, fontBtn);
        if(fontWeightDropdown && !fontWeightDropdown.contains(e.target)) closeDropdown(fontWeightDropdown, fontWeightBtn);
      });

      // Unit label toggle
      toggleUnitLabelsButton?.addEventListener('click', () => {
        showUnitLabels = !showUnitLabels;
        toggleUnitLabelsButton.textContent = showUnitLabels ? 'Hide Unit Labels' : 'Show Unit Labels';
        toggleUnitLabelsButton.dataset.active = String(showUnitLabels);
        updateCountdown();
        syncRestoreDefaultsVisibility();
      });


      // Bloom border toggle
      toggleBloomBorderButton?.addEventListener('click', () => {
        bloomBorderOn = !bloomBorderOn;
        applyBloomBorderState();
        syncRestoreDefaultsVisibility();
      });

      // Condensed window title toggle
      toggleCondensedWindowButton?.addEventListener('click', () => {
        useCondensedWindowFormat = !useCondensedWindowFormat;
        toggleCondensedWindowButton.textContent = useCondensedWindowFormat ? 'Use Full Window Title' : 'Condense Window Title';
        updateCountdown();
        syncRestoreDefaultsVisibility();
      });

      // Condensed countdown toggle
      toggleCondensedCountdownButton?.addEventListener('click', () => {
        useCondensedCountdownFormat = !useCondensedCountdownFormat;
        toggleCondensedCountdownButton.textContent = useCondensedCountdownFormat ? 'Use Full Countdown' : 'Condense Countdown';
        updateCountdown();
        syncRestoreDefaultsVisibility();
      });

      // Control panel toggle (smoother + tiny bump)
      function setPanelHidden(hidden) {
        controlPanel.classList.toggle('hidden', hidden);
        document.body.classList.toggle('settings-open', !hidden);
        if (settingsBackdrop) settingsBackdrop.setAttribute('aria-hidden', String(hidden));

        toggleArrow.textContent = hidden ? '⚙' : '❮';
        toggleArrow.setAttribute('aria-label', hidden ? 'Open settings' : 'Close settings');
        toggleArrow.setAttribute('aria-expanded', String(!hidden));
      }

      if (settingsBackdrop) {
        settingsBackdrop.addEventListener('click', () => setPanelHidden(true));
      }

      // Initialize closed (so the page loads clean)
      setPanelHidden(true);

      toggleArrow.addEventListener('click', () => {
        const nextHidden = !controlPanel.classList.contains('hidden');
        setPanelHidden(nextHidden);
        toggleArrow.classList.add('bump');
        setTimeout(() => toggleArrow.classList.remove('bump'), 220);
      });

      // Keyboard shortcuts: S toggles, Esc closes
      document.addEventListener('keydown', (e) => {
        const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : '';
        if (tag === 'input' || tag === 'textarea' || tag === 'select') return;
        if (e.key === 'Escape') {
          if (!controlPanel.classList.contains('hidden')) setPanelHidden(true);
        }
        if (e.key === 's' || e.key === 'S') {
          setPanelHidden(!controlPanel.classList.contains('hidden'));
        }
      });
}

    startCountdown();
  </script>

  <div class="unsplash-credit" id="unsplashCredit" hidden></div>
</body>
</html>
